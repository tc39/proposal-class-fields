<!doctype html>
<meta charset="utf8">
<pre class=metadata>
title: Public and private instance fields proposal
stage: 3
contributors: Daniel Ehrenberg, Jeff Morrison, Kevin Smith, Kevin Gibbons
</pre>
<style>
emu-example figure {
  align-items: initial;
  width: 100%;
}

emu-note {
  display: block;
  border-left-color: #474747;
}

emu-note span.note {
  display: inline-block;
  color: #fff;
  background-color: #474747;
  width: initial;
  padding-right: 50px;
}

emu-note div.note-contents {
  padding-left: 5px;
}

emu-note[type=editor] {
  border-left-color: #900;
}
emu-note[type=editor] span.note {
  background-color: #900;
}

emu-example {
  border-left: 5px solid #006387;
  margin: 1em 0;
}

emu-example figure figcaption:first-child {
  display: inline-block;
  color: #fff;
  background-color: #006387;
  margin: 0;
  padding: 0 50px 0 5px;
  font-weight: normal;
  text-transform: uppercase;
  margin-left: -5px;
}

emu-example figure figcaption:nth-child(2) {
  margin: 0;
  padding: 0;
  padding-left: 5px;
  margin-left: -5px;
  font-size: 20px;
  font-weight: bold;
  margin-bottom: 10px;
}

emu-example p:nth-of-type(1) {
  margin-top: 0;
}

emu-example figure {
  padding-left: 5px;
  display: block;
  margin: 0;
}

emu-example pre {
  margin: 0;
}
</style>

<emu-intro id=sec-intro>
  <h1>Introduction</h1>
  <p>This document attempts to integrate the <a href="https://tc39.github.io/proposal-class-public-fields">public fields</a> and <a href="https://tc39.github.io/proposal-private-fields">private fields</a> proposals into a single, coherent, orthogonal whole. See <a href="https://github.com/littledan/proposal-class-fields">the explainer</a> for an overview.</p>
</emu-intro>


<emu-clause id=sec-syntax>
  <h1>Syntax</h1>

  <emu-clause id=sec-new-syntax>
    <h1>New Productions</h1>

    <emu-grammar>
      ClassElementName[Yield, Await] :
        PropertyName[?Yield, ?Await]
        PrivateName

      FieldDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] Initializer[In, ~Yield, ~Await]?

      PrivateName ::
        `#` IdentifierName
    </emu-grammar>
  </emu-clause>

  <emu-clause id=sec-updated-syntax>
    <h1>Updated Productions</h1>

    <emu-grammar>
      ClassElement[Yield, Await] :
        MethodDefinition[?Yield, ?Await]
        `static` MethodDefinition[?Yield, ?Await]
        <ins>FieldDefinition[?Yield, ?Await] `;`</ins>
        `;`

      MemberExpression[Yield, Await] :
        PrimaryExpression[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        MemberExpression[?Yield, ?Await] `.` IdentifierName
        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await]
        SuperProperty[?Yield, ?Await]
        MetaProperty
        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        <ins>MemberExpression[?Yield, ?Await] `.` PrivateName</ins>

      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await]
        <ins>CallExpression[?Yield, ?Await] `.` PrivateName</ins>
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-static-semantics-early-errors">
    <h1>Static Semantics: Early Errors</h1>
    <emu-grammar>
      FieldDefinition :
        ClassElementName Initializer?
    </emu-grammar>
    <ul>
      <li>It is a Syntax Error if ContainsArguments of |Initializer| is *true*.</li>
      <li>It is a Syntax Error if |Initializer| is present and |Initializer| Contains |SuperCall| is *true*.</li>
    </ul>

    <emu-grammar>
      ClassBody : ClassElementList
    </emu-grammar>
    <ul>
      <li>It is a Syntax Error if PrivateBoundNames of |ClassBody| contains any duplicate entries.</li>
    </ul>

    <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
    <ul>
      <li>
        It is a Syntax Error if PropName of |FieldDefinition| is `"constructor"`.
      </li>
    </ul>

    <emu-grammar>ClassElementName : PrivateName `;`</emu-grammar>
    <ul>
      <li>
        It is a Syntax Error if StringValue of |PrivateName| is `"#constructor"`.
      </li>
    </ul>

    <emu-note>
      <p>These static rules have been modified to produce an early error if the `delete` operator is applied to a private reference.</p>
    </emu-note>
    <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
    <ul>
      <li>
        It is a Syntax Error if the |UnaryExpression| is contained in strict mode code and the derived |UnaryExpression| is <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>, <ins><emu-grammar>MemberExpression : MemberExpression `.` PrivateName</emu-grammar>, or <emu-grammar>CallExpression : CallExpression `.` PrivateName</emu-grammar></ins>.
      </li>
      <li>
        <p>It is a Syntax Error if the derived |UnaryExpression| is
          <br>
          <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
          <br>
          and |CoverParenthesizedExpressionAndArrowParameterList| ultimately derives a phrase that, if used in place of |UnaryExpression|, would produce a Syntax Error according to these rules. This rule is recursively applied.</p>
      </li>
    </ul>
    <emu-note>
      <p>The last rule means that expressions such as `delete (((foo)))` produce early errors because of recursive application of the first rule.</p>
    </emu-note>
    <emu-note type=editor>Private fields may not be deleted in any case. There are only ever private names defined inside class bodies. Inside of a class body, code will be in strict mode, and the above rule applies. Outside of a class body, there will be no private names defined, so the below rule will apply.</emu-note>

    <emu-grammar>ScriptBody : StatementList</emu-grammar>
    <ul>
      <li>It is a Syntax Error if AllPrivateNamesValid of |StatementList| with an empty List as an argument is *false* unless the source code is eval code that is being processed by a direct eval.</li>
    </ul>
    <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
    <ul>
      <li>It is a Syntax Error if AllPrivateNamesValid of |ModuleItemList| with an empty List as an argument is *false*.</li>
    </ul>
    <emu-note type=editor>References to PrivateNames which are not lexically present cause an early error.</emu-note>
  <emu-clause id="sec-all-private-names-valid" aoid="AllPrivateNamesValid">
    <h1>Static Semantics: AllPrivateNamesValid</h1>
    AllPrivateNamesValid is an abstract operation which takes _names_ as an argument.
    <emu-grammar>MemberExpression[Yield, Await] : MemberExpression[?Yield, ?Await] `.` PrivateName</emu-grammar>
    <emu-alg>
      1. If StringValue of |PrivateName| is in _names_, return *true*.
      1. Return *false*.
    </emu-alg>

    <emu-grammar>CallExpression[Yield, Await] : CallExpression[?Yield, ?Await] `.` PrivateName</emu-grammar>
    <emu-alg>
      1. If StringValue of |PrivateName| is in _names_, return *true*.
      1. Return *false*.
    </emu-alg>

    <emu-grammar> ClassBody[Yield, Await] : ClassElementList[?Yield, ?Await] </emu-grammar>
    <emu-alg>
      1. Let _newNames_ be the concatenation of _names_ with PrivateBoundNames of |ClassBody|.
      1. Return AllPrivateNamesValid of |ClassElementList| with the argument _newNames_.
    </emu-alg>

    For all other grammatical productions, recurse on subexpressions/substatements, passing in the _names_ of the caller. If all pieces return *true*, then return *true*. If any returns *false*, return *false*.
  <emu-note type=editor>TODO: Elaborate the preceding paragraph with spec text inserted in each relevant place</emu-note>
  </emu-clause>
<emu-clause id="sec-performeval">
  <h1>Runtime Semantics: PerformEval ( _x_, _evalRealm_, _strictCaller_, _direct_ )</h1>
  <emu-clause id="sec-performeval-rules-in-initializer">
    <h1>Additional Early Error Rules for Eval Inside |Initializer|</h1>
    <p>These static semantics are applied by PerformEval when a direct eval call occurs inside a class field initializer.</p>
    <emu-grammar>ScriptBody : StatementList</emu-grammar>
    <ul>
      <li>It is a Syntax Error if ContainsArguments of |StatementList| is *true*.</li>
      <li>The remaining eval rules apply as <a href="https://tc39.github.io/ecma262/#sec-performeval-rules-outside-constructors">outside a constructor</a>, <a href="https://tc39.github.io/ecma262/#sec-performeval-rules-outside-methods">inside a method</a>, and <a href="https://tc39.github.io/ecma262/#sec-performeval-rules-outside-functions">inside a function</a>.</li>
    </ul>
  </emu-clause>
</emu-clause>
  </emu-clause>
</emu-clause>


<emu-clause id="sec-internal-algorithms">
<h1>Modified algorithms</h1>

<emu-clause id="static-semantics-propname">
  <h1>Static Semantics: PropName</h1>
  <emu-grammar>
    FieldDefinition : ClassElementName Initializer?
  </emu-grammar>
  <emu-alg>
    1. Return PropName of |ClassElementName|.
  </emu-alg>

  <emu-grammar>
      ClassElementName[Yield, Await] : PropertyName[?Yield, ?Await]
  </emu-grammar>
  <emu-alg>
    1. Return PropName of |PropertyName|.
  </emu-alg>

  <emu-grammar>
      ClassElementName[Yield, Await] : PrivateName
  </emu-grammar>
  <emu-alg>
    1. Return ~empty~.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-runtime-semantics-evaluate-name">
  <h1>Runtime Semantics: Evaluation</h1>
  <emu-grammar>
      ClassElementName[Yield, Await] : PropertyName[?Yield, ?Await]
  </emu-grammar>
  <emu-alg>
    1. Return the result of evaluating |PropertyName|.
  </emu-alg>

  <emu-grammar>
      ClassElementName[Yield, Await] : PrivateName
  </emu-grammar>
  <emu-alg>
    1. Let _bindingName_ be StringValue of |PrivateName|.
    1. Let _field_ be NewPrivateName(_bindingName_).
    1. Let _scope_ be the running execution context's PrivateNameEnvironment.
    1. Let _scopeEnvRec_ be _scope_'s EnvironmentRecord.
    1. Perform ! _scopeEnvRec_.InitializeBinding(_bindingName_, _field_).
    1. Return _field_.
  </emu-alg>
  <emu-note type=editor>Each time a class declaration executes, distinct internal Private Names are created. This means, that they cannot directly access each other's private state if a method of one is called with the other as a receiver.</emu-note>

</emu-clause>

<emu-clause id="static-semantics-class-element-evaluation">
  <h1>Runtime Semantics: ClassElementEvaluation</h1>
  <p>With parameters _object_ and _enumerable_.</p>

  <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
  <emu-alg>
    1. Return ClassFieldDefinitionEvaluation of |FieldDefinition| with parameter _object_.
  </emu-alg>
  <emu-grammar>
      ClassElement : MethodDefinition
      ClassElement : `static` MethodDefinition
  </emu-grammar>
  <emu-alg>
    1. Perform ? PropertyDefinitionEvaluation with parameters _object_ and _enumerable_.
    1. Return an empty List.
  </emu-alg>
</emu-clause>

<emu-clause id="runtime-semantics-class-field-definition-evaluation">
  <h1>Runtime Semantics: ClassFieldDefinitionEvaluation</h1>

  <p>With parameter _homeObject_.</p>

  <emu-grammar>
    FieldDefinition : ClassElementName Initializer?
  </emu-grammar>
  <emu-alg>
    1. Let _fieldName_ be the result of evaluating |ClassElementName|.
    1. ReturnIfAbrupt(_fieldName_).
    1. If |Initializer_opt| is present,
      1. Let _lex_ be the Lexical Environment of the running execution context.
      1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.
      1. Let _initializer_ be FunctionCreate(~Method~, _formalParameterList_, |Initializer|, _lex_, *true*).
      1. Perform MakeMethod(_initializer_, _homeObject_).
      1. Let _isAnonymousFunctionDefinition_ be IsAnonymousFunctionDefinition(|Initializer|).
    1. Else,
      1. Let _initializer_ be ~empty~.
      1. Let _isAnonymousFunctionDeclaration_ be *false*.
    1. Return a List containing Record {
         [[Name]]: _fieldName_, 
         [[Initializer]]: _initializer_,
         [[IsAnonymousFunctionDefinition]]: _isAnonymousFunctionDefinition_
       }.
  </emu-alg>
</emu-clause>

<emu-clause id="runtime-semantics-class-public-field-definition-evaluation">
  <h1>Runtime Semantics: EvaluateBody</h1>

  <p>With parameter _functionObject_ and List _argumentsList_.</p>

  <emu-grammar>
    Initializer :
      `=` AssignmentExpression
  </emu-grammar>
  <emu-alg>
    1. Assert: _argumentsList_ is empty.
    1. Return the result of evaluating |AssignmentExpression|.
  </emu-alg>
  <emu-note>FunctionDeclarationInstantiation would not have any observable behaviour here, so its call is omitted.</emu-note>
</emu-clause>

    <!-- es6num="9.2.11" -->
    <emu-clause id="sec-setfunctionname" aoid="SetFunctionName">
      <h1>SetFunctionName ( _F_, _name_ [ , _prefix_ ] )</h1>
      <p>The abstract operation SetFunctionName requires a Function argument _F_, a String, Symbol, <ins>or Private Name</ins> argument _name_ and optionally a String argument _prefix_. This operation adds a `name` property to _F_ by performing the following steps:</p>
      <emu-alg>
        1. Assert: _F_ is an extensible object that does not have a `name` own property.
        1. Assert: Type(_name_) is either Symbol, String, <ins>or Private Name</ins>.
        1. Assert: If _prefix_ was passed, then Type(_prefix_) is String.
        1. If Type(_name_) is Symbol, then
          1. Let _description_ be _name_'s [[Description]] value.
          1. If _description_ is *undefined*, set _name_ to the empty String.
          1. Else, set _name_ to the concatenation of `"["`, _description_, and `"]"`.
        1. <ins>Else if _name_ is a Private Name,</ins>
          1. <ins>Set _name_ to _name_'s [[Description]] value.</ins>
        1. If _prefix_ was passed, then
          1. Set _name_ to the concatenation of _prefix_, code unit 0x0020 (SPACE), and _name_.
        1. Return ! DefinePropertyOrThrow(_F_, `"name"`, PropertyDescriptor{[[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true*}).
      </emu-alg>
    </emu-clause>

<emu-clause id="sec-define-field">
  <h1>DefineField(_receiver_, _fieldRecord_)</h1>
    <emu-alg>
    1. Assert: Type(_receiver_) is Object.
    1. Assert: _fieldRecord_ is a Record as created by ClassFieldDefinitionEvaluation.
    1. Let _fieldName_ be _fieldRecord_.[[Name]].
    1. Let _initializer_ be _fieldRecord_.[[Initializer]].
    1. If _initializer_ is not ~empty~, then
      1. Let _initValue_ be ? Call(_initializer_, _receiver_).
    1. Else, let _initValue_ be *undefined*.
    1. If _fieldRecord_.[[IsAnonymousFunctionDefinition]] is *true*, then
      1. Let _hasNameProperty_ be ? HasOwnProperty(_initValue_, `"name"`).
      1. If _hasNameProperty_ is *false*, perform SetFunctionName(_initValue_, _fieldName_).
    1. If _fieldName_ is a Private Name,
      1. Perform ? PrivateFieldAdd(_fieldName_, _receiver_, _initValue_).
    1. Else,
      1. Assert: IsPropertyKey(_fieldName_) is *true*.
      1. Perform ? CreateDataPropertyOrThrow(_receiver_, _fieldName_, _initValue_).
    <emu-alg>
</emu-clause>
<emu-note type=editor>TODO: Set the running execution context's PrivateNameEnvironment when calling a function (<a href="https://github.com/anba/proposal-class-fields.git">Issue #40</a>).</emu-note>


<emu-clause id="initialize-public-instance-fields">
  <h1>InitializeInstanceFields ( _O_, _constructor_ )</h1>

  <emu-alg>
    1. Assert: Type ( _O_ ) is Object.
    1. Assert: Assert _constructor_ is an ECMAScript function object.
    1. Let _fieldRecords_ be the value of _constructor_'s [[Fields]] internal slot.
    1. For each item _fieldRecord_ in order from _fieldRecords_,
      1. Perform ? DefineField(_O_, _fieldRecord_).
    1. Return.
  </emu-alg>
  <emu-note type=editor>Private fields are added to the object one by one, interspersed with evaluation of the initializers, following the construction of the receiver. These semantics allow for a later initializer to refer to a previously private field.</emu-note>
</emu-clause>

<emu-clause id="sec-private-names-static-semantics-stringvalue">
  <h1>Static Semantics: StringValue</h1>
  <emu-see-also-para op="StringValue"></emu-see-also-para>
  <emu-grammar>
    PrivateName ::
      `#` IdentifierName
  </emu-grammar>
  <emu-alg>
    1. Return the String value consisting of the sequence of code units corresponding to |PrivateName|. In determining the sequence any occurrences of `\\` |UnicodeEscapeSequence| are first replaced with the code point represented by the |UnicodeEscapeSequence| and then the code points of the entire |PrivateName| are converted to code units by UTF16Encoding (<emu-xref href="#sec-utf16encoding"></emu-xref>) each code point.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-private-bound-names" aoid="PrivateBoundNames">
  <h1>Static Semantics: PrivateBoundNames</h1>
  <emu-grammar>
      FieldDefinition : ClassElementName Initializer?
  </emu-grammar>
  <emu-alg>
    1. Return PrivateBoundNames of |ClassElementName|
  </emu-alg>

  <emu-grammar>
    ClassElementName : PrivateName
  </emu-grammar>
  <emu-alg>
    1. Return a new List containing the StringValue of |PrivateName|.
  </emu-alg>

  <emu-grammar>
    ClassElementName : PropertyName
  </emu-grammar>
  <emu-alg>
    1. Return a new empty List.
  </emu-alg>

  <emu-grammar>
    ClassElement : MethodDefinition `;`

    ClassElement : `static` MethodDefinition `;`

    ClassElement : `;`
  </emu-grammar>
  <emu-alg>
    1. Return a new empty List.
  </emu-alg>

  <emu-grammar>
    ClassElementList : ClassElement
  </emu-grammar>
  <emu-alg>
    1. Return PrivateBoundNames of |ClassElement|.
  </emu-alg>

  <emu-grammar>
    ClassElementList : ClassElementList ClassElement
  </emu-grammar>
  <emu-alg>
    1. Let _names_ be PrivateBoundNames of |ClassElementList|.
    1. Append to _names_ the elements of PrivateBoundNames of |ClassElement|.
    1. Return _names_.
  </emu-alg>

  <emu-grammar>
    ClassBody : ClassElementList
  </emu-grammar>
  <emu-alg>
    1. Return PrivateBoundNames of |ClassElementList|.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-static-semantics-contains-arguments">
  <h1>Static Semantics: ContainsArguments</h1>
  <emu-grammar>
    IdentifierReference : Identifier
  </emu-grammar>
  <emu-alg>
    1. If the StringValue of |Identifier| is `"arguments"`, return *true*.
    2. Else, return *false*.
  </emu-alg>

  <emu-grammar>
    FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`

    FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`

    FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return *false*.
  </emu-alg>

  <emu-grammar>
    MethodDefinition :
      PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
      `get` PropertyName `(` `)` `{` FunctionBody `}`
      `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return the result of ContainsArguments for |PropertyName|.
  </emu-alg>

  <emu-grammar>
    GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return the result of ContainsArguments for |PropertyName|.
  </emu-alg>

  <emu-grammar>
    GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

    GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

    GeneratorExpression : `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return *false*.
  </emu-alg>

  <emu-grammar>ClassBody : ClassElementList</emu-grammar>
  <emu-alg>
    1. Return *false*.
  </emu-alg>

  <emu-grammar>
    AsyncMethod : `async` [no LineTerminator here] PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return the result of ContainsArguments for |PropertyName|.
  </emu-alg>

  <emu-grammar>
    AsyncFunctionDeclaration : `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`

    AsyncFunctionDeclaration : `async` [no LineTerminator here] `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

    AsyncFunctionExpression : `async` [no LineTerminator here] `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

    AsyncFunctionExpression : `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return *false*.
  </emu-alg>

  For all other grammatical productions, recurse on all nonterminals. If any piece returns *true*, then return *true*. Otherwise return *false*.
  <emu-note type=editor>TODO: Elaborate the preceding paragraph with spec text inserted in each relevant place</emu-note>
</emu-clause>

<emu-clause id="class-definitions">
  <h1>Class Definitions</h1>

  <emu-clause id="static-semantics-is-static">
    <h1>Static Semantics: IsStatic</h1>

    <ins class="block">
      <emu-grammar>ClassElement : FieldDefinition</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </ins>
  </emu-clause>

  <emu-clause id="runtime-semantics-class-definition-evaluation">
    <h1>Runtime Semantics: ClassDefinitionEvaluation</h1>
    <p>With parameter _className_.</p>
    <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
    <emu-alg>
      1. Let _lex_ be the LexicalEnvironment of the running execution context.
      1. Let _classScope_ be NewDeclarativeEnvironment(_lex_).
      1. Let _classScopeEnvRec_ be _classScope_'s EnvironmentRecord.
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.CreateImmutableBinding(_className_, *true*).
      1. <ins>Let _outerPrivateEnvironment_ be the PrivateNameEnvironment of the running execution context.</ins>
      1. <ins>Let _classPrivateEnvironment_ be NewDeclarativeEnvironment(_outerPrivateEnvironment_).</ins>
      1. <ins>Let _classPrivateEnvRec_ be _classPrivateEnvironment_'s EnvironmentRecord.</ins>
      1. <ins>If |ClassBody_opt| is present, then</ins>
        1. <ins>For each element _dn_ of the PrivateBoundNames of |ClassBody_opt|,</ins>
          1. <ins>Perform _classPrivateEnvRec_.CreateImmutableBinding(_dn_, *true*).</ins>
      1. If |ClassHeritage_opt| is not present, then
        1. Let _protoParent_ be the intrinsic object %ObjectPrototype%.
        1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
      1. Else,
        1. Set the running execution context's LexicalEnvironment to _classScope_.
        1. <ins>NOTE: The running execution context's PrivateNameEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.</ins>
        1. Let _superclass_ be the result of evaluating |ClassHeritage|.
        1. Set the running execution context's LexicalEnvironment to _lex_.
        1. ReturnIfAbrupt(_superclass_).
        1. If _superclass_ is *null*, then
          1. Let _protoParent_ be *null*.
          1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
        1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
        1. Else,
          1. Let _protoParent_ be ? Get(_superclass_, `"prototype"`).
          1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
          1. Let _constructorParent_ be _superclass_.
      1. Let _proto_ be ObjectCreate(_protoParent_).
      1. If |ClassBody_opt| is not present, let _constructor_ be ~empty~.
      1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
      1. If _constructor_ is ~empty~, then
        1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor(... args){ super (...args);}</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
        1. Else,
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor( ){ }</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
      1. Set the running execution context's LexicalEnvironment to _classScope_.
      1. <ins>Set the running execution context's PrivateNameEnvironment to _classPrivateEnvironment_.</ins>
      1. Let _constructorInfo_ be the result of performing DefineMethod for _constructor_ with arguments _proto_ and _constructorParent_ as the optional _functionPrototype_ argument.
      1. Assert: _constructorInfo_ is not an abrupt completion.
      1. Let _F_ be _constructorInfo_.[[Closure]].
      1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then set _F_.[[ConstructorKind]] to `"derived"`.
      1. Perform MakeConstructor(_F_, *false*, _proto_).
      1. Perform MakeClassConstructor(_F_).
      1. Perform CreateMethodProperty(_proto_, `"constructor"`, _F_).
      1. If |ClassBody_opt| is not present, let _methods_ be a new empty List.
      1. Else, let <del>_methods_</del><ins>_elements_</ins> be NonConstructorMethodDefinitions of |ClassBody|.
      1. <ins>Let _fieldRecords_ be a new empty List.</ins>
      1. For each |ClassElement| <del>_m_</del><ins>_e_</ins> in order from <del>_methods_</del><ins>_elements_</ins>
        1. If IsStatic of <del>_m_</del><ins>_e_</ins> is *false*, then
          1. Let _fields_ be the result of performing <del>PropertyDefinitionEvaluation for _m_</del><ins>ClassElementEvaluation for _e_</ins> with arguments _proto_ and *false*.
        1. Else,
          1. Let _fields_ be the result of performing <del>PropertyDefinitionEvaluation for _m_</del><ins>ClassElementEvaluation for _e_</ins> with arguments _F_ and *false*.
        1. If _fields_ is an abrupt completion, then
          1. Set the running execution context's LexicalEnvironment to _lex_.
          1. <ins>Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.</ins>
          1. Return Completion(_status_).
        1. <ins>Append to _fieldRecords_ the elements of _fields_.</ins>
      1. Set the running execution context's LexicalEnvironment to _lex_.
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.InitializeBinding(_className_, _F_).
      1. <ins>Set the value of _F_'s [[Fields]] internal slot to _fieldRecords_.</ins>
      1. <ins>Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.</ins>
      1. Return _F_.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="[[construct]]">
  <h1>[[Construct]] ( _argumentsList_, _newTarget_)</h1>
  <p>
    The [[Construct]] internal method for an ECMAScript Function object _F_ is
    called with parameters _argumentsList_ and _newTarget_. _argumentsList_ is
    a possibly empty List of ECMAScript language values. The following steps are
    taken:
  </p>
  <emu-alg>
    1. Assert: _F_ is an ECMAScript function object.
    1. Assert: Type(_newTarget_) is Object.
    1. Let _callerContext_ be the running execution context.
    1. Let _kind_ be _F_.[[ConstructorKind]].
    1. If _kind_ is `"base"`, then
      1. Let _thisArgument_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%ObjectPrototype%"`).
    1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, _newTarget_).
    1. Assert: _calleeContext_ is now the running execution context.
    1. If _kind_ is `"base"`, then
      1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).
      1. <ins>Let _result_ be InitializeInstanceFields(_thisArgument_, _F_).</ins>
      1. <ins>If _result_ is an abrupt completion, then</ins>
        1. <ins>Remove _calleeContext_ from execution context stack and restore
           _callerContext_ as the running execution context.</ins>
        1. <ins>Return Completion(_result_).</ins>
    1. Let _constructorEnv_ be the LexicalEnvironment of _calleeContext_.
    1. Let _envRec_ be _constructorEnv_'s EnvironmentRecord.
    1. Let _result_ be OrdinaryCallEvaluateBody(_F_, _argumentsList_).
    1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
    1. If _result_.[[Type]] is ~return~, then
      1. If Type(_result_.[[Value]]) is Object, return NormalCompletion(_result_.[[Value]]).
      1. If _kind_ is `"base"`, return NormalCompletion(_thisArgument_).
      1. If _result_.[[Value]] is not *undefined*, throw a *TypeError* exception.
    1. Else, ReturnIfAbrupt(_result_).
    1. Return ? _envRec_.GetThisBinding().
  </emu-alg>
  <emu-note type=editor>Fields are added by the base class constructor when the super chain reaches up to that, rather than by the subclass constructor when creating the object, in order to be analogous to ES2015 subclassable builtins. See <a href="https://github.com/tc39/proposal-private-fields/issues/17">this GitHub thread</a> for more discussion.</emu-note>
</emu-clause>

<emu-clause id="the-super-keyword">
  <h1>The `super` Keyword</h1>

  <emu-clause id="sec-super-keyword-runtime-semantics-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>
    <emu-grammar>SuperCall : `super` Arguments</emu-grammar>
    <emu-alg>
      1. Let _newTarget_ be GetNewTarget().
      1. If _newTarget_ is *undefined*, throw a *ReferenceError* exception.
      1. Let _func_ be ? GetSuperConstructor().
      1. Let _argList_ be ArgumentListEvaluation of |Arguments|.
      1. ReturnIfAbrupt(_argList_).
      1. Let _result_ be ? Construct(_func_, _argList_, _newTarget_).
      1. Let _thisER_ be GetThisEnvironment( ).
      1. Let _F_ be _thisER_.[[FunctionObject]].
      1. Assert: _F_ is an ECMAScript function object.
      1. <ins>Perform ? InitializeInstanceFields(_result_, _F_).</ins>
      1. Return ? _thisER_.BindThisValue(_result_).
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-delete-operator">
  <h1>The `delete` Operator</h1>

  <emu-clause id="sec-delete-operator-runtime-semantics-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>
    <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
    <emu-alg>
      1. Let _ref_ be the result of evaluating |UnaryExpression|.
      1. ReturnIfAbrupt(_ref_).
      1. If Type(_ref_) is not Reference, return *true*.
      1. If IsUnresolvableReference(_ref_) is *true*, then
        1. Assert: IsStrictReference(_ref_) is *false*.
        1. Return *true*.
      1. If IsPropertyReference(_ref_) is *true*, then
        1. <ins>Assert: IsPrivateReference(_ref_) is *false*.</ins>
        1. If IsSuperReference(_ref_), throw a *ReferenceError* exception.
        1. Let _baseObj_ be ! ToObject(GetBase(_ref_)).
        1. Let _deleteStatus_ be ? _baseObj_.[[Delete]](GetReferencedName(_ref_)).
        1. If _deleteStatus_ is *false* and IsStrictReference(_ref_) is *true*, throw a *TypeError* exception.
        1. Return _deleteStatus_.
      1. Else _ref_ is a Reference to an Environment Record binding,
        1. Let _bindings_ be GetBase(_ref_).
        1. Return ? _bindings_.DeleteBinding(GetReferencedName(_ref_)).
    </emu-alg>
    <emu-note>
      <p>When a `delete` operator occurs within strict mode code, a *SyntaxError* exception is thrown if its |UnaryExpression| is a direct reference to a variable, function argument, or function name. In addition, if a `delete` operator occurs within strict mode code and the property to be deleted has the attribute { [[Configurable]]: *false* }, a *TypeError* exception is thrown.</p>
    </emu-note>
  </emu-clause>
</emu-clause>

        <!-- es6num="19.2.1.1.1" -->
        <emu-clause id="sec-createdynamicfunction" aoid="CreateDynamicFunction">
          <h1>Runtime Semantics: CreateDynamicFunction( _constructor_, _newTarget_, _kind_, _args_ )</h1>
          <p>The abstract operation CreateDynamicFunction is called with arguments _constructor_, _newTarget_, _kind_, and _args_. _constructor_ is the constructor function that is performing this action, _newTarget_ is the constructor that `new` was initially applied to, _kind_ is either `"normal"`, `"generator"`, or `"async"`, and _args_ is a List containing the actual argument values that were passed to _constructor_. The following steps are taken:</p>
          <emu-alg>
            1. Assert: The execution context stack has at least two elements.
            1. Let _callerContext_ be the second to top element of the execution context stack.
            1. Let _callerRealm_ be _callerContext_'s Realm.
            1. Let _calleeRealm_ be the current Realm Record.
            1. Perform ? HostEnsureCanCompileStrings(_callerRealm_, _calleeRealm_).
            1. If _newTarget_ is *undefined*, set _newTarget_ to _constructor_.
            1. If _kind_ is `"normal"`, then
              1. Let _goal_ be the grammar symbol |FunctionBody[~Yield, ~Await]|.
              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[~Yield, ~Await]|.
              1. Let _fallbackProto_ be `"%FunctionPrototype%"`.
            1. Else if _kind_ is `"generator"`, then
              1. Let _goal_ be the grammar symbol |GeneratorBody|.
              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[+Yield, ~Await]|.
              1. Let _fallbackProto_ be `"%Generator%"`.
            1. Else,
              1. Assert: _kind_ is `"async"`.
              1. Let _goal_ be the grammar symbol |AsyncFunctionBody|.
              1. Let _parameterGoal_ be the grammar symbol |FormalParameters[~Yield, +Await]|.
              1. Let _fallbackProto_ be `"%AsyncFunctionPrototype%"`.
            1. Let _argCount_ be the number of elements in _args_.
            1. Let _P_ be the empty String.
            1. If _argCount_ = 0, let _bodyText_ be the empty String.
            1. Else if _argCount_ = 1, let _bodyText_ be _args_[0].
            1. Else _argCount_ &gt; 1,
              1. Let _firstArg_ be _args_[0].
              1. Set _P_ to ? ToString(_firstArg_).
              1. Let _k_ be 1.
              1. Repeat, while _k_ &lt; _argCount_-1
                1. Let _nextArg_ be _args_[_k_].
                1. Let _nextArgString_ be ? ToString(_nextArg_).
                1. Set _P_ to the result of concatenating the previous value of _P_, the String `","` (a comma), and _nextArgString_.
                1. Increase _k_ by 1.
              1. Let _bodyText_ be _args_[_k_].
            1. Set _bodyText_ to ? ToString(_bodyText_).
            1. Let _parameters_ be the result of parsing _P_, interpreted as UTF-16 encoded Unicode text as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, using _parameterGoal_ as the goal symbol. Throw a *SyntaxError* exception if the parse fails.
            1. Let _body_ be the result of parsing _bodyText_, interpreted as UTF-16 encoded Unicode text as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, using _goal_ as the goal symbol. Throw a *SyntaxError* exception if the parse fails.
            1. Let _strict_ be ContainsUseStrict of _body_.
            1. If any static semantics errors are detected for _parameters_ or _body_, throw a *SyntaxError* or a *ReferenceError* exception, depending on the type of the error. If _strict_ is *true*, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied. Parsing and early error detection may be interweaved in an implementation-dependent manner.
            1. If _strict_ is *true* and IsSimpleParameterList of _parameters_ is *false*, throw a *SyntaxError* exception.
            1. If any element of the BoundNames of _parameters_ also occurs in the LexicallyDeclaredNames of _body_, throw a *SyntaxError* exception.
            1. If _body_ Contains |SuperCall| is *true*, throw a *SyntaxError* exception.
            1. If _parameters_ Contains |SuperCall| is *true*, throw a *SyntaxError* exception.
            1. If _body_ Contains |SuperProperty| is *true*, throw a *SyntaxError* exception.
            1. If _parameters_ Contains |SuperProperty| is *true*, throw a *SyntaxError* exception.
            1. If _kind_ is `"generator"`, then
              1. If _parameters_ Contains |YieldExpression| is *true*, throw a *SyntaxError* exception.
            1. If _kind_ is `"async"`, then
              1. If _parameters_ Contains |AwaitExpression| is *true*, throw a *SyntaxError* exception.
            1. If _strict_ is *true*, then
              1. If BoundNames of _parameters_ contains any duplicate elements, throw a *SyntaxError* exception.
            1. <ins>Let _privateNames_ be an empty List.</ins>
            1. <ins>If AllPrivateNamesValid of _body_ with the argument _privateNames_ is *false*, throw a *SyntaxError* exception.</ins>
            1. <ins>If AllPrivateNamesValid of _parameters_ with the argument _privateNames_ is *false*, throw a *SyntaxError* exception.</ins>
            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_).
            1. Let _F_ be FunctionAllocate(_proto_, _strict_, _kind_).
            1. Let _realmF_ be _F_.[[Realm]].
            1. Let _scope_ be _realmF_.[[GlobalEnv]].
            1. Perform FunctionInitialize(_F_, ~Normal~, _parameters_, _body_, _scope_).
            1. If _kind_ is `"generator"`, then
              1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
              1. Perform DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
            1. Else if _kind_ is `"normal"`, perform MakeConstructor(_F_).
            1. NOTE: Async functions are not constructable and do not have a [[Construct]] internal method or a `"prototype"` property.
            1. Perform SetFunctionName(_F_, `"anonymous"`).
            1. Return _F_.
          </emu-alg>
          <emu-note>
            <p>A `prototype` property is created for every non-async function created using CreateDynamicFunction to provide for the possibility that the function will be used as a constructor.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>
    </emu-clause>


    <emu-clause id="sec-eval-x">
      <h1>eval ( _x_ )</h1>
      <emu-clause id="sec-evaldeclarationinstantiation" aoid="EvalDeclarationInstantiation">
        <h1>Runtime Semantics: EvalDeclarationInstantiation( _body_, _varEnv_, _lexEnv_, _strict_ )</h1>
        <p>When the abstract operation EvalDeclarationInstantiation is called with arguments _body_, _varEnv_, _lexEnv_, and _strict_, the following steps are taken:</p>
        <emu-alg>
          1. Let _varNames_ be the VarDeclaredNames of _body_.
          1. Let _varDeclarations_ be the VarScopedDeclarations of _body_.
          1. Let _lexEnvRec_ be _lexEnv_'s EnvironmentRecord.
          1. Let _varEnvRec_ be _varEnv_'s EnvironmentRecord.
          1. If _strict_ is *false*, then
            1. If _varEnvRec_ is a global Environment Record, then
              1. For each _name_ in _varNames_, do
                1. If _varEnvRec_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.
                1. NOTE: `eval` will not create a global var declaration that would be shadowed by a global lexical declaration.
            1. Let _thisLex_ be _lexEnv_.
            1. Assert: The following loop will terminate.
            1. Repeat while _thisLex_ is not the same as _varEnv_,
              1. Let _thisEnvRec_ be _thisLex_'s EnvironmentRecord.
              1. If _thisEnvRec_ is not an object Environment Record, then
                1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.
                1. For each _name_ in _varNames_, do
                  1. If _thisEnvRec_.HasBinding(_name_) is *true*, then
                    1. Throw a *SyntaxError* exception.
                    1. NOTE: Annex <emu-xref href="#sec-variablestatements-in-catch-blocks"></emu-xref> defines alternate semantics for the above step.
                  1. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.
              1. Let _thisLex_ be _thisLex_'s outer environment reference.
          1. <ins>Let _privateNames_ be an empty List.</ins>
          1. <ins>Let _privateEnv_ be the running execution context's PrivateNameEnvironment.</ins>
          1. <ins>Repeat while _privateEnv_ is not *null*,</ins>
            1. <ins>For each binding named _N_ in _privateEnv_,</ins>
              1. <ins>If _privateNames_ does not contain _N_, append _N_ to _privateNames_.</ins>
            1. <ins>Let _privateEnv_ be _privateEnv_'s outer environment reference.</ins>
          1. <ins>If AllPrivateNamesValid of _body_ with the argument _privateNames_ is *false*, throw a *SyntaxError* exception.</ins>
          1. Let _functionsToInitialize_ be a new empty List.
          1. Let _declaredFunctionNames_ be a new empty List.
          1. For each _d_ in _varDeclarations_, in reverse list order do
            1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then
              1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, or an |AsyncFunctionDeclaration|.
              1. NOTE If there are multiple function declarations for the same name, the last declaration is used.
              1. Let _fn_ be the sole element of the BoundNames of _d_.
              1. If _fn_ is not an element of _declaredFunctionNames_, then
                1. If _varEnvRec_ is a global Environment Record, then
                  1. Let _fnDefinable_ be ? _varEnvRec_.CanDeclareGlobalFunction(_fn_).
                  1. If _fnDefinable_ is *false*, throw a *TypeError* exception.
                1. Append _fn_ to _declaredFunctionNames_.
                1. Insert _d_ as the first element of _functionsToInitialize_.
          1. NOTE: Annex <emu-xref href="#sec-web-compat-evaldeclarationinstantiation"></emu-xref> adds additional steps at this point.
          1. Let _declaredVarNames_ be a new empty List.
          1. For each _d_ in _varDeclarations_, do
            1. If _d_ is a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
              1. For each String _vn_ in the BoundNames of _d_, do
                1. If _vn_ is not an element of _declaredFunctionNames_, then
                  1. If _varEnvRec_ is a global Environment Record, then
                    1. Let _vnDefinable_ be ? _varEnvRec_.CanDeclareGlobalVar(_vn_).
                    1. If _vnDefinable_ is *false*, throw a *TypeError* exception.
                  1. If _vn_ is not an element of _declaredVarNames_, then
                    1. Append _vn_ to _declaredVarNames_.
          1. NOTE: No abnormal terminations occur after this algorithm step unless _varEnvRec_ is a global Environment Record and the global object is a Proxy exotic object.
          1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _body_.
          1. For each element _d_ in _lexDeclarations_ do
            1. NOTE Lexically declared names are only instantiated here but not initialized.
            1. For each element _dn_ of the BoundNames of _d_ do
              1. If IsConstantDeclaration of _d_ is *true*, then
                1. Perform ? _lexEnvRec_.CreateImmutableBinding(_dn_, *true*).
              1. Else,
                1. Perform ? _lexEnvRec_.CreateMutableBinding(_dn_, *false*).
          1. For each Parse Node _f_ in _functionsToInitialize_, do
            1. Let _fn_ be the sole element of the BoundNames of _f_.
            1. Let _fo_ be the result of performing InstantiateFunctionObject for _f_ with argument _lexEnv_.
            1. If _varEnvRec_ is a global Environment Record, then
              1. Perform ? _varEnvRec_.CreateGlobalFunctionBinding(_fn_, _fo_, *true*).
            1. Else,
              1. Let _bindingExists_ be _varEnvRec_.HasBinding(_fn_).
              1. If _bindingExists_ is *false*, then
                1. Let _status_ be ! _varEnvRec_.CreateMutableBinding(_fn_, *true*).
                1. Assert: _status_ is not an abrupt completion because of validation preceding step 12.
                1. Perform ! _varEnvRec_.InitializeBinding(_fn_, _fo_).
              1. Else,
                1. Perform ! _varEnvRec_.SetMutableBinding(_fn_, _fo_, *false*).
          1. For each String _vn_ in _declaredVarNames_, in list order do
            1. If _varEnvRec_ is a global Environment Record, then
              1. Perform ? _varEnvRec_.CreateGlobalVarBinding(_vn_, *true*).
            1. Else,
              1. Let _bindingExists_ be _varEnvRec_.HasBinding(_vn_).
              1. If _bindingExists_ is *false*, then
                1. Let _status_ be ! _varEnvRec_.CreateMutableBinding(_vn_, *true*).
                1. Assert: _status_ is not an abrupt completion because of validation preceding step 12.
                1. Perform ! _varEnvRec_.InitializeBinding(_vn_, *undefined*).
          1. Return NormalCompletion(~empty~).
        </emu-alg>
      </emu-clause>
    </emu-clause>

</emu-clause>

<emu-clause id="sec-private-names">
  <h1>Private Names and references</h1>
<p>The <dfn>Private Name</dfn> specification type is used to describe a globally unique identifier which represents a private field name. A private name may be installed on any ECMAScript object with the PrivateFieldAdd internal algorithm, and then read or written using PrivateFieldGet and PrivateFieldSet.</p>

  <p>Each PrivateName value immutably holds an associated value called [[Description]] that is a String value.</p>

<p>All ECMAScript objects have a new additional internal slot, [[PrivateFieldValues]], which is a List of Records of the form { [[PrivateName]]: Private Name, [[PrivateFieldValue]]: ECMAScript value }. This List represents the values of the private fields for the object. All objects, including Proxies and all host environment-provided objects, have this internal slot, but primitives such as Numbers do not.</p>

<emu-note type=editor>
<p>
  Private fields are designed to have semantics analogous to WeakMaps. However, the implied garbage collection semantics are weaker: If all the references to a WeakMap are inaccessible, but there is still a reference to a key which was in the WeakMap, one would expect the value to be eventually collected. However, PrivateNameIdentifiers specifically do not have this connotation: because the reference from the Identifier to the Value is in a Record which the Object points to, the value would not be collected, even if nothing else points to the identifier.
</p>
<p>
  Private Names are a specification type here, not directly observable to ECMAScript code. However, in <a href="https://github.com/tc39/proposal-private-fields/blob/master/DECORATORS.md">a decorator integration strawman</a>, an object wrapping Private Names would be exposed to allow greater metaprogramming.
</p>
</emu-note>

<emu-note type=editor>
  Private fields are deliberately inaccessible outside of the class body. It is proposed that there could be an "escape hatch" to access them though some sort of reflective mechanism; see <a href="https://github.com/tc39/proposal-private-fields/issues/33">the GitHub thread</a>. This proposal deliberately omits any such escape hatch.
</emu-note>

<emu-clause id="sec-objectcreate" aoid="ObjectCreate">
  <h1>ObjectCreate (_proto_ [ , _internalSlotsList_ ])</h1>
  <p>The abstract operation ObjectCreate with argument _proto_ (an object or null) is used to specify the runtime creation of new ordinary objects. The optional argument _internalSlotsList_ is a List of the names of additional internal slots that must be defined as part of the object. If the list is not provided, a new empty List is used. This abstract operation performs the following steps:</p>
  <emu-alg>
    1. If _internalSlotsList_ was not provided, let _internalSlotsList_ be a new empty List.
    1. Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.
    1. Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.
    1. Set _obj_.[[Prototype]] to _proto_.
    1. Set _obj_.[[Extensible]] to *true*.
    1. <ins>Set _obj_.[[PrivateFieldValues]] to an empty List.</ins>
    1. Return _obj_.
  </emu-alg>
  <emu-note type=editor>TODO: All ECMAScript objects, including Proxies, and any user exotic object, should have a [[PrivateFieldValues]] internal slot initialized to an empty List.</emu-note>
</emu-clause>

<emu-clause id="sec-newprivatename" aoid="NewPrivateName">
  <h1>NewPrivateName ( _description_ )</h1>
  <emu-alg>
    1. Return a new unique Private Name value whose [[Description]] value is _description_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-privatefieldfind" aoid="PrivateFieldFind">
  <h1>PrivateFieldFind (_P_, _O_)</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. Assert: _O_ is an object with a [[PrivateFieldValues]] internal slot.
    1. For each element _entry_ in _O_.[[PrivateFieldValues]],
      1. If _entry_.[[PrivateName]] is _P_, return _entry_.
    1. Return ~empty~.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-privatefieldadd" aoid="PrivateFieldAdd">
  <h1>PrivateFieldAdd (_P_, _O_, _value_)</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. If _O_ is not an object, throw a *TypeError* exception.
    1. Let _entry_ be PrivateFieldFind(_P_, _O_).
    1. If _entry_ is not ~empty~, throw a *TypeError* exception.
    1. Append { [[PrivateName]]: P, [[PrivateFieldValue]]: _value_ } to _O_.[[PrivateFieldValues]].
  </emu-alg>
</emu-clause>

<emu-clause id="sec-privatefieldget" aoid="PrivateFieldGet">
  <h1>PrivateFieldGet (_P_, _O_ )</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. If _O_ is not an object, throw a *TypeError* exception.
    1. Let _entry_ be PrivateFieldFind(_P_, _O_).
    1. If _entry_ is ~empty~, throw a *TypeError* exception.
    1. Return _entry_.[[PrivateFieldValue]].
  </emu-alg>
</emu-clause>

<emu-clause id="sec-privatefieldset" aoid="PrivateFieldSet">
  <h1>PrivateFieldSet (_P_, _O_, _value_ )</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. If _O_ is not an object, throw a *TypeError* exception.
    1. Let _entry_ be PrivateFieldFind(_P_, _O_).
    1. If _entry_ is ~empty~, throw a *TypeError* exception.
    1. Set _entry_.[[PrivateFieldValue]] to _value_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-private-references-runtime-semantics-evaluation">
  <h1>Runtime Semantics: Evaluation</h1>
  <emu-grammar>MemberExpression : MemberExpression `.` PrivateName</emu-grammar>
  <emu-alg>
    1. Let _baseReference_ be the result of evaluating |MemberExpression|.
    1. Let _baseValue_ be ? GetValue(_baseReference_).
    1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
    1. Let _fieldNameString_ be the StringValue of |PrivateName|.
    1. Return MakePrivateReference(_bv_, _fieldNameString_).
  </emu-alg>

  <emu-grammar>CallExpression : CallExpression `.` PrivateName</emu-grammar>
  <emu-alg>
    1. Let _baseReference_ be the result of evaluating |CallExpression|.
    1. Let _baseValue_ be ? GetValue(_baseReference_).
    1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
    1. Let _fieldNameString_ be the StringValue of |PrivateName|.
    1. Return MakePrivateReference(_bv_, _fieldNameString_).
  </emu-alg>
</emu-clause>

<emu-clause id="sec-reference-specification-type">
  <h1>The Reference Specification Type</h1>
  <emu-note>
    <p>The Reference type is used to explain the behaviour of such operators as `delete`, `typeof`, the assignment operators, the `super` keyword and other language features. For example, the left-hand operand of an assignment is expected to produce a reference.</p>
  </emu-note>
  <p>A <dfn>Reference</dfn> is a resolved name or property binding. A Reference consists of <ins>four</ins> components, the <em>base</em> value, the <em>referenced name</em>, the Boolean valued <em>strict reference</em> flag, <ins>and the Boolean valued <em>private reference</em> flag</ins>. The <em>base</em> value is either *undefined*, an Object, a Boolean, a String, a Symbol, a Number, or an Environment Record (<emu-xref href="#sec-environment-records"></emu-xref>). A _base_ value of *undefined* indicates that the Reference could not be resolved to a binding. The <em>referenced name</em> is a String value or a Symbol value.</p>
  <p>A Super Reference is a Reference that is used to represent a name binding that was expressed using the super keyword. A Super Reference has an additional _thisValue_ component and its _base_ value will never be an Environment Record.</p>
  <p>The following abstract operations are used in this specification to access the components of references:</p>
  <ul>
    <li>
      GetBase(V). Returns the _base_ value component of the reference V.
    </li>
    <li>
      GetReferencedName(V). Returns the <i>referenced name</i> component of the reference V.
    </li>
    <li>
      IsStrictReference(V). Returns the <i>strict reference</i> flag component of the reference V.
    </li>
    <li>
      HasPrimitiveBase(V). Returns *true* if Type(_base_) is Boolean, String, Symbol, or Number.
    </li>
    <li>
      IsPropertyReference(V). Returns *true* if either the _base_ value is an object or HasPrimitiveBase(V) is *true*; otherwise returns *false*.
    </li>
    <li>
      IsUnresolvableReference(V). Returns *true* if the _base_ value is *undefined* and *false* otherwise.
    </li>
    <li>
      IsSuperReference(V). Returns *true* if this reference has a _thisValue_ component.
    </li>
    <li>
      <ins>IsPrivateReference(V). Returns the <i>private reference</i> flag component of the reference V.</ins>
    </li>
  </ul>
  <p>The following abstract operations are used in this specification to operate on references:</p>

  <!-- es6num="6.2.3.1" -->
  <emu-clause id="sec-getvalue" aoid="GetValue">
    <h1>GetValue ( _V_ )</h1>
    <emu-alg>
      1. ReturnIfAbrupt(_V_).
      1. If Type(_V_) is not Reference, return _V_.
      1. Let _base_ be GetBase(_V_).
      1. If IsUnresolvableReference(_V_), throw a *ReferenceError* exception.
      1. If IsPropertyReference(_V_), then
        1. If HasPrimitiveBase(_V_), then
          1. Assert: In this case, _base_ will never be *null* or *undefined*.
          1. Let _base_ be ToObject(_base_).
        1. <ins>If IsPrivateReference(_V_), then</ins>
          1. <ins>Let _env_ be the running execution context's PrivateNameEnvironment.</ins>
          1. <ins>Let _field_ be ? ResolveBinding(GetReferencedName(_V_), _env_).</ins>
          1. <ins>Assert: _field_ is a Private Name.</ins>
          1. <ins>Return ? PrivateFieldGet(_field_, _base_).</ins>
        1. Return ? _base_.[[Get]](GetReferencedName(_V_), GetThisValue(_V_)).
      1. Else _base_ must be an Environment Record,
        1. Return ? _base_.GetBindingValue(GetReferencedName(_V_), IsStrictReference(_V_)) (see <emu-xref href="#sec-environment-records"></emu-xref>).
    </emu-alg>
    <emu-note>
      <p>The object that may be created in step 5.a.ii is not accessible outside of the above abstract operation and the ordinary object [[Get]] internal method. An implementation might choose to avoid the actual creation of the object.</p>
    </emu-note>
  </emu-clause>

  <!-- es6num="6.2.3.2" -->
  <emu-clause id="sec-putvalue" aoid="PutValue">
    <h1>PutValue ( _V_, _W_ )</h1>
    <emu-alg>
      1. ReturnIfAbrupt(_V_).
      1. ReturnIfAbrupt(_W_).
      1. If Type(_V_) is not Reference, throw a *ReferenceError* exception.
      1. Let _base_ be GetBase(_V_).
      1. If IsUnresolvableReference(_V_), then
        1. If IsStrictReference(_V_) is *true*, then
          1. Throw a *ReferenceError* exception.
        1. Let _globalObj_ be GetGlobalObject().
        1. Return ? Set(_globalObj_, GetReferencedName(_V_), _W_, *false*).
      1. Else if IsPropertyReference(_V_), then
        1. If HasPrimitiveBase(_V_) is *true*, then
          1. Assert: In this case, _base_ will never be *null* or *undefined*.
          1. Set _base_ to ToObject(_base_).
        1. <ins>If IsPrivateReference(_V_), then</ins>
          1. <ins>Let _env_ be the running execution context's PrivateNameEnvironment.</ins>
          1. <ins>Let _field_ be ? ResolveBinding(GetReferencedName(_V_), _env_).</ins>
          1. <ins>Assert: _field_ is a Private Name.</ins>
          1. <ins>Perform ? PrivateFieldSet(_field_, _base_, _W_).</ins>
        1. Else,
          1. Let _succeeded_ be ? _base_.[[Set]](GetReferencedName(_V_), _W_, GetThisValue(_V_)).
          1. If _succeeded_ is *false* and IsStrictReference(_V_) is *true*, throw a *TypeError* exception.
        1. Return.
      1. Else _base_ must be an Environment Record.
        1. Return ? _base_.SetMutableBinding(GetReferencedName(_V_), _W_, IsStrictReference(_V_)) (see <emu-xref href="#sec-environment-records"></emu-xref>).
    </emu-alg>
    <emu-note>
      <p>The object that may be created in step 6.a.ii is not accessible outside of the above algorithm and the ordinary object [[Set]] internal method. An implementation might choose to avoid the actual creation of that object.</p>
    </emu-note>
  </emu-clause>

  <!--
  1. Replace all occurances of "Return a value of type Reference..." with calls to MakeReference
  2. Rename MakeSuperPropertyReference to MakeSuperReference for consistency.

  <emu-clause id="sec-makereference" aoid="MakeReference">
    <h1>MakeReference ( _baseValue_, _referencedName_, _strict_ )</h1>
    <emu-alg>
      1. Return a value of type Reference whose base value is _baseValue_, whose referenced name is _referencedName_, whose strict reference flag is _strict_, and whose private reference component is *false*.
    </emu-alg>
  </emu-clause>
  -->

  <emu-clause id="sec-makeprivatereference" aoid="MakePrivateReference">
    <h1>MakePrivateReference ( _baseValue_, _fieldName_ )</h1>
    <emu-alg>
      1. Return a value of type Reference whose base value is _baseValue_, whose referenced name is _fieldName_, whose strict reference flag is *true*, and whose private reference component is *true*.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-execution-contexts">
  <h1>Execution Contexts</h1>
    <emu-table id="table-23" caption="Additional State Components for ECMAScript Code Execution Contexts">
      <table>
        <tbody>
        <tr>
          <th>
            Component
          </th>
          <th>
            Purpose
          </th>
        </tr>
        <tr>
          <td>
            LexicalEnvironment
          </td>
          <td>
            Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.
          </td>
        </tr>
        <tr>
          <td>
            VariableEnvironment
          </td>
          <td>
            Identifies the Lexical Environment whose EnvironmentRecord holds bindings created by |VariableStatement|s within this execution context.
          </td>
        </tr>
        <tr>
          <td>
            <ins>PrivateNameEnvironment</ins>
          </td>
          <td>
            <ins>Identifies the Lexical Environment whose EnvironmentRecord holds internal private names created by |FieldDefinition|s.</ins>
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
  <emu-note>The PrivateNameEnvironment Lexical Context is always a chain of Declaration Contexts. Each name begins with `"#"`.</emu-note>

  <emu-note type=editor>Private names could be specified by lumping it all into the LexicalEnvironment. However, this would create false conflicts with object environment records that would need to be resolved. Further, it seems logically cleaner to separate out the distinct namespace into a distinct object.</emu-note>

  When a new execution context is created for an ECMAScript code execution context, the PrivateNameIdentifiers value is inherited from the running execution context, or if none exists, a new Declaration Context with a *null* parent.
  <emu-note type=editor>TODO: Elaborate the preceding paragraph with spec text inserted in each relevant place</emu-note>
</emu-clause>

</emu-clause>
</emu-clause>

  <!-- es6num="11.9" -->
  <emu-clause id="sec-automatic-semicolon-insertion">
    <h1>Automatic Semicolon Insertion</h1>
    <p>Most ECMAScript statements and declarations <del>must be</del><ins>are logically</ins> terminated with a semicolon. Such semicolons may always appear explicitly in the source text. For convenience, however, such semicolons may be omitted from the source text in certain situations. These situations are described by saying that semicolons are automatically inserted into the source code token stream in those situations.</p>

    <!-- es6num="11.9.1" -->
    <emu-clause id="sec-rules-of-automatic-semicolon-insertion" namespace=asi-rules>
      <h1>Rules of Automatic Semicolon Insertion</h1>
      <p>In the following rules, &ldquo;token&rdquo; means the actual recognized lexical token determined using the current lexical goal symbol as described in clause <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref>.</p>
      <p>There are three basic rules of semicolon insertion:</p>
      <ol>
        <li>
          <p>When, as the source text is parsed from left to right, a token (called the <em>offending token</em>) is encountered that is not allowed by any production of the grammar, then a semicolon is automatically inserted before the offending token if one or more of the following conditions is true:</p>
          <ul>
            <li>
              The offending token is separated from the previous token by at least one |LineTerminator|.
            </li>
            <li>
              The offending token is `}`.
            </li>
            <li>
              The previous token is `)` and the inserted semicolon would then be parsed as the terminating semicolon of a do-while statement (<emu-xref href="#sec-do-while-statement"></emu-xref>).
            </li>
          </ul>
        </li>
        <li>
          When, as the source text is parsed from left to right, the end of the input stream of tokens is encountered and the parser is unable to parse the input token stream as a single instance of the goal nonterminal, then a semicolon is automatically inserted at the end of the input stream.
        </li>
        <li>
          When, as the source text is parsed from left to right, a token is encountered that is allowed by some production of the grammar, but the production is a <em>restricted production</em> and the token would be the first token for a terminal or nonterminal immediately following the annotation &ldquo;[no |LineTerminator| here]&rdquo; within the restricted production (and therefore such a token is called a restricted token), and the restricted token is separated from the previous token by at least one |LineTerminator|, then a semicolon is automatically inserted before the restricted token.
        </li>
      </ol>
      <p>However, there is an additional overriding condition on the preceding rules: a semicolon is never inserted automatically if the semicolon would then be parsed as an empty statement or if that semicolon would become one of the two semicolons in the header of a `for` statement (see <emu-xref href="#sec-for-statement"></emu-xref>).</p>
      <emu-note>
        <p>The following are the only restricted productions in the grammar:</p>
        <emu-grammar>
          UpdateExpression[Yield, Await] :
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`

          ContinueStatement[Yield, Await] :
            `continue` `;`
            `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          BreakStatement[Yield, Await] :
            `break` `;`
            `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          ReturnStatement[Yield, Await] :
            `return` `;`
            `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          ThrowStatement[Yield, Await] :
            `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          ArrowFunction[In, Yield, Await] :
            ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=&gt;` ConciseBody[?In]

          YieldExpression[In, Await] :
            `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]
            `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
        </emu-grammar>
        <p>The practical effect of these restricted productions is as follows:</p>
        <ul>
          <li>
            When a `++` or `--` token is encountered where the parser would treat it as a postfix operator, and at least one |LineTerminator| occurred between the preceding token and the `++` or `--` token, then a semicolon is automatically inserted before the `++` or `--` token.
          </li>
          <li>
            When a `continue`, `break`, `return`, `throw`, or `yield` token is encountered and a |LineTerminator| is encountered before the next token, a semicolon is automatically inserted after the `continue`, `break`, `return`, `throw`, or `yield` token.
          </li>
        </ul>
        <p>The resulting practical advice to ECMAScript programmers is:</p>
        <ul>
          <li>
            A postfix `++` or `--` operator should appear on the same line as its operand.
          </li>
          <li>
            An |Expression| in a `return` or `throw` statement or an |AssignmentExpression| in a `yield` expression should start on the same line as the `return`, `throw`, or `yield` token.
          </li>
          <li>
            A |LabelIdentifier| in a `break` or `continue` statement should be on the same line as the `break` or `continue` token.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <ins>Automatic semicolon insertion applies for all source text, including class bodies. In particular, semicolons may be omitted after class field declarations in certain conditions. Although the same insertion logic described above applies within class bodies, the practicalities of writing class bodies in a semicolon-free style differs between class bodies and other ECMAScript code; see <emu-xref href="#sec-asi-hazards-in-class-bodies"></emu-xref> for some consequences of this property.</ins>
      </emu-note>
    </emu-clause>

    <!-- es6num="11.9.2" -->
    <emu-clause id="sec-examples-of-automatic-semicolon-insertion">
      <h1>Examples of Automatic Semicolon Insertion</h1>
      <ins><em>This section is non-normative.</em></ins>

      <p>The source</p>
      <pre><code class="javascript">{ 1 2 } 3</code></pre>
      <p>is not a valid sentence in the ECMAScript grammar, even with the automatic semicolon insertion rules. In contrast, the source</p>
      <pre><code class="javascript">
        { 1
        2 } 3
      </code></pre>
      <p>is also not a valid ECMAScript sentence, but is transformed by automatic semicolon insertion into the following:</p>
      <pre><code class="javascript">
        { 1
        ;2 ;} 3;
      </code></pre>
      <p>which is a valid ECMAScript sentence.</p>
      <p>The source</p>
      <pre><code class="javascript">
        for (a; b
        )
      </code></pre>
      <p>is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion because the semicolon is needed for the header of a `for` statement. Automatic semicolon insertion never inserts one of the two semicolons in the header of a `for` statement.</p>
      <p>The source</p>
      <pre><code class="javascript">
        return
        a + b
      </code></pre>
      <p>is transformed by automatic semicolon insertion into the following:</p>
      <pre><code class="javascript">
        return;
        a + b;
      </code></pre>
      <emu-note>
        <p>The expression `a + b` is not treated as a value to be returned by the `return` statement, because a |LineTerminator| separates it from the token `return`.</p>
      </emu-note>
      <p>The source</p>
      <pre><code class="javascript">
        a = b
        ++c
      </code></pre>
      <p>is transformed by automatic semicolon insertion into the following:</p>
      <pre><code class="javascript">
        a = b;
        ++c;
      </code></pre>
      <emu-note>
        <p>The token `++` is not treated as a postfix operator applying to the variable `b`, because a |LineTerminator| occurs between `b` and `++`.</p>
      </emu-note>
      <p>The source</p>
      <pre><code class="javascript">
        if (a &gt; b)
        else c = d
      </code></pre>
      <p>is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion before the `else` token, even though no production of the grammar applies at that point, because an automatically inserted semicolon would then be parsed as an empty statement.</p>
      <p>The source</p>
      <pre><code class="javascript">
        a = b + c
        (d + e).print()
      </code></pre>
      <p>is <em>not</em> transformed by automatic semicolon insertion, because the parenthesized expression that begins the second line can be interpreted as an argument list for a function call:</p>
      <pre><code class="javascript">a = b + c(d + e).print()</code></pre>
      <p>In the circumstance that an assignment statement must begin with a left parenthesis, it is a good idea for the programmer to provide an explicit semicolon at the end of the preceding statement rather than to rely on automatic semicolon insertion.</p>
    </emu-clause>

    <emu-clause id="sec-hazards-of-automatic-semicolon-insertion">
      <h1>Hazards of Automatic Semicolon Insertion</h1>
      <em>This section is non-normative.</em>
      <p>ECMAScript programs can be written in a style with very few semicolons, based on a heavy dependence on automatic semicolon insertion. However, as described above, semicolons are not inserted at every newline, and some of these cases which do not have an automatically inserted semicolon can be counter-intuitive or confusing.</p>

      <p>As new syntactic features are added to ECMAScript, additional cases requiring explicit semicolons emerge over time. As such, consistently explicit semicolon use is recommended.</p>

      <p>The term "automatic semicolon insertion hazard" refers, informally, to a place where a developer may expect a semicolon to be inserted, but according to the rules described above, it is not. The rest of this section describes a number of automatic semicolon insertion hazards in this version of ECMAScript.</p>
      <emu-clause id="sec-asi-hazards-in-statement-lists">
        <h1>Automatic Semicolon Insertion Hazards in Statement Lists</h1>
        <p>In a |StatementList|, many |StatementListItem|s end in semicolons, which may be omitted using automatic semicolon insertion. As a consequence of the rules above, at the end of a line ending an expression, a semicolon will be required if the following line begins with any of the following:
        <ul>
          <li><strong>An opening parenthesis (<code>(</code>)</strong>. Without a semicolon, the two lines together will be treated as a function call.</li>
          <li><strong>An opening square bracket (<code>[</code>)</strong>. Without a semicolon, the two lines together will be treated as property access, rather than an array literal.</li>
          <li><strong>A template string (<code>`</code>)</strong>. Without a semicolon, the two lines together will be interpreted as tagged template literal, with the previous expression as the function tag.</li>
          <li><strong>Unary <code>+</code> or <code>-</code></strong>. Without a semicolon, the two lines together will be interpreted as a usage of the corresponding infix operator.</li>
          <li><strong>A RegExp literal</strong>. Without a semicolon, the two lines together may be parsed instead as a division, for example if the RegExp has flags.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-asi-hazards-in-class-bodies">
        <h1>Automatic Semicolon Insertion Hazards in the Top Level of Class Bodies</h1>
        <p>At the top level of class bodies, the only significant case where semicolons are used is in field declarations. As a consequence of the rules above, at the end of a field declaration with an initializer expression, a semicolon is required if the following line begins with any of the following:</p>
        <ul>
          <li><strong>A computed property name field or method</strong>. Without a semicolon, a field declaration with a computed property name will be treated as a property access; a method with a computed property name would be a Syntax Error.</li>
          <li><strong>A generator method</strong>. A missing semicolon is a Syntax Error.</li>
          <li><strong>A field named <code>in</code> or <code>instanceof</code></strong>. Without a semicolon, those tokens will instead be interpreted as an operator.</li>
        </ul>

        <p>Additionally, the declaration of a field named <code>get</code>, <code>set</code> or <code>static</code></strong>, if it does not have an initializer, is not at the end of the class body, and is not followed by a non-static non-async generator method, requires a semicolon. Without a semicolon, these tokens will be treated as modifiers to the following class element declaration. Note that <code>async</code> does not have this property, as async method declarations do not permit a newline between the <code>async</code> token and the method name.</p>
        </ul>
      </emu-clause>
    </emu-clause>
  </emu-clause>
