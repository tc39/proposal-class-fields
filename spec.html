<!doctype html>
<meta charset="utf8">
<pre class=metadata>
title: Integrated public and private fields proposal
stage: 3
contributors: Daniel Ehrenberg, Jeff Morrison, Kevin Smith, Kevin Gibbons
</pre>
<style>
emu-example figure {
  align-items: initial;
  width: 100%;
}

emu-note {
  display: block;
  border-left-color: #474747;
}

emu-note span.note {
  display: inline-block;
  color: #fff;
  background-color: #474747;
  width: initial;
  padding-right: 50px;
}

emu-note div.note-contents {
  padding-left: 5px;
}

emu-note[type=editor] {
  border-left-color: #900;
}
emu-note[type=editor] span.note {
  background-color: #900;
}

emu-example {
  border-left: 5px solid #006387;
  margin: 1em 0;
}

emu-example figure figcaption:first-child {
  display: inline-block;
  color: #fff;
  background-color: #006387;
  margin: 0;
  padding: 0 50px 0 5px;
  font-weight: normal;
  text-transform: uppercase;
  margin-left: -5px;
}

emu-example figure figcaption:nth-child(2) {
  margin: 0;
  padding: 0;
  padding-left: 5px;
  margin-left: -5px;
  font-size: 20px;
  font-weight: bold;
  margin-bottom: 10px;
}

emu-example p:nth-of-type(1) {
  margin-top: 0;
}

emu-example figure {
  padding-left: 5px;
  display: block;
  margin: 0;
}

emu-example pre {
  margin: 0;
}
</style>

<emu-intro id=sec-intro>
  <h1>Introduction</h1>
  <p>This document attempts to integrate the <a href="https://tc39.github.io/proposal-class-public-fields">public fields</a> and <a href="https://tc39.github.io/proposal-private-fields">private fields</a> proposals into a single, coherent, orthogonal whole. See <a href="https://github.com/littledan/proposal-class-fields">the explainer</a> for an overview.</p>
</emu-intro>


<emu-clause id=sec-syntax>
  <h1>Syntax</h1>

  <emu-clause id=sec-new-syntax>
    <h1>New Productions</h1>

    <emu-grammar>
      ClassElementName[Yield, Await] :
        PropertyName[?Yield, ?Await]
        PrivateName

      FieldDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] Initializer[In, ~Yield, ~Await]?

      PrivateName ::
        `#` IdentifierName
    </emu-grammar>
  </emu-clause>

  <emu-clause id=sec-updated-syntax>
    <h1>Updated Productions</h1>

    <emu-grammar>
      ClassElement[Yield, Await] :
        MethodDefinition[?Yield, ?Await]
        `static` MethodDefinition[?Yield, ?Await]
        <ins>FieldDefinition[?Yield, ?Await] `;`</ins>
        <ins>`static` FieldDefinition[?Yield, ?Await] `;`</ins>
        `;`

      MemberExpression[Yield, Await] :
        PrimaryExpression[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        MemberExpression[?Yield, ?Await] `.` IdentifierName
        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await]
        SuperProperty[?Yield, ?Await]
        MetaProperty
        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        <ins>MemberExpression[?Yield, ?Await] `.` PrivateName</ins>

      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await]
        <ins>CallExpression[?Yield, ?Await] `.` PrivateName</ins>
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-static-semantics-early-errors">
    <h1>Static Semantics: Early Errors</h1>
    <emu-grammar>
      FieldDefinition[Yield] :
        PropertyName[?Yield] Initializer?
    </emu-grammar>
    <ul>
      <li>It is a Syntax Error if ContainsArguments of |Initializer| is *true*.</li>
      <li>It is a Syntax Error if |Initializer| is present and |Initializer| Contains |SuperCall| is *true*.</li>
    </ul>

    <emu-grammar>
      ClassBody : ClassElementList
    </emu-grammar>
    <ul>
      <li>It is a Syntax Error if PrivateBoundNames of |ClassBody| contains any duplicate entries.</li>
    </ul>

    <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
    <ul>
      <li>
        It is a Syntax Error if PropName of |FieldDefinition| is `"prototype"` or `"constructor"`.
      </li>
    </ul>

    <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
    <ul>
      <li>
        It is a Syntax Error if PropName of |FieldDefinition| is `"constructor"`.
      </li>
    </ul>

    <emu-grammar>ClassElementName : PrivateName `;`</emu-grammar>
    <ul>
      <li>
        It is a Syntax Error if StringValue of |PrivateName| is `"#constructor"`.
      </li>
    </ul>

    <emu-note>
      <p>These static rules have been modified to produce an early error if the `delete` operator is applied to a private reference.</p>
    </emu-note>
    <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
    <ul>
      <li>
        It is a Syntax Error if the |UnaryExpression| is contained in strict mode code and the derived |UnaryExpression| is <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>, <ins><emu-grammar>MemberExpression : MemberExpression `.` PrivateName</emu-grammar>, or <emu-grammar>CallExpression : CallExpression `.` PrivateName</emu-grammar></ins>.
      </li>
      <li>
        <p>It is a Syntax Error if the derived |UnaryExpression| is
          <br>
          <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
          <br>
          and |CoverParenthesizedExpressionAndArrowParameterList| ultimately derives a phrase that, if used in place of |UnaryExpression|, would produce a Syntax Error according to these rules. This rule is recursively applied.</p>
      </li>
    </ul>
    <emu-note>
      <p>The last rule means that expressions such as `delete (((foo)))` produce early errors because of recursive application of the first rule.</p>
    </emu-note>
    <emu-note type=editor>Private fields may not be deleted in any case. There are only ever private names defined inside class bodies. Inside of a class body, code will be in strict mode, and the above rule applies. Outside of a class body, there will be no private names defined, so the below rule will apply.</emu-note>

    <emu-grammar>Script : ScriptBody?</emu-grammar>
    <emu-alg>
      1. Let _names_ be an empty List.
      1. If |Script| is parsed directly from PerformEval,
        1. Let _env_ be the running execution context's PrivateNameEnvironment.
        1. Repeat while _env_ is not *null*,
          1. For each binding named _N_ in _env_,
            1. If _names_ does not contain _N_, append _N_ to _names_.
          1. Let _env_ be _env_'s outer environment reference.
      1. If AllPrivateNamesValid of |ScriptBody| with the argument _names_ is *false*, throw a SyntaxError.
    </emu-alg>
    <emu-grammar>Module : ModuleBody?</emu-grammar>
    <ul>
      <li>It is a Syntax Error if AllPrivateNamesValid of <emu-nt>ModuleBody</emu-nt> with an empty List as an argument is *false*.</li>
    </ul>
    <emu-note type=editor>References to PrivateNames which are not lexically present cause an early error.</emu-note>
  <emu-clause id="sec-all-private-names-valid" aoid="AllPrivateNamesValid">
    <h1>Static Semantics: AllPrivateNamesValid</h1>
    AllPrivateNamesValid is an abstract operation which takes _names_ as an argument.
    <emu-grammar>MemberExpression[Yield, Await] : MemberExpression[?Yield, ?Await] `.` PrivateName</emu-grammar>
    <emu-alg>
      1. If StringValue of |PrivateName| is in _names_, return *true*.
      1. Return *false*.
    </emu-alg>

    <emu-grammar>CallExpression[Yield, Await] : CallExpression[?Yield, ?Await] `.` PrivateName</emu-grammar>
    <emu-alg>
      1. If StringValue of |PrivateName| is in _names_, return *true*.
      1. Return *false*.
    </emu-alg>

    <emu-grammar> ClassBody[Yield, Await] : ClassElementList[?Yield, ?Await] </emu-grammar>
    <emu-alg>
      1. Let _newNames_ be the concatenation of _names_ with PrivateBoundNames of |ClassBody|.
      1. Return AllPrivateNamesValid of |ClassElementList| with the argument _newNames_.
    </emu-alg>

    For all other grammatical productions, recurse on subexpressions/substatements, passing in the _names_ of the caller. If all pieces return *true*, then return *true*. If any returns *false*, return *false*.
  <emu-note type=editor>TODO: Elaborate the preceding paragraph with spec text inserted in each relevant place</emu-note>
  </emu-clause>
<emu-clause id="sec-performeval">
  <h1>Runtime Semantics: PerformEval ( _x_, _evalRealm_, _strictCaller_, _direct_ )</h1>
  <emu-clause id="sec-performeval-rules-in-initializer">
    <h1>Additional Early Error Rules for Eval Inside |Initializer|</h1>
    <p>These static semantics are applied by PerformEval when a direct eval call occurs inside a class field initializer.</p>
    <emu-grammar>ScriptBody : StatementList</emu-grammar>
    <ul>
      <li>It is a Syntax Error if ContainsArguments of |StatementList| is *true*.</li>
      <li>The remaining eval rules apply as <a href="https://tc39.github.io/ecma262/#sec-performeval-rules-outside-constructors">outside a constructor</a>, <a href="https://tc39.github.io/ecma262/#sec-performeval-rules-outside-methods">inside a method</a>, and <a href="https://tc39.github.io/ecma262/#sec-performeval-rules-outside-functions">inside a function</a>.</li>
    </ul>
  </emu-clause>
</emu-clause>
  </emu-clause>
</emu-clause>


<emu-clause id="sec-internal-algorithms">
<h1>Modified algorithms</h1>

<emu-clause id="static-semantics-propname">
  <h1>Static Semantics: PropName</h1>
  <emu-grammar>
    FieldDefinition : ClassElementName Initializer?
  </emu-grammar>
  <emu-alg>
    1. Return PropName of |ClassElementName|.
  </emu-alg>

  <emu-grammar>
      ClassElementName[Yield, Await] : PropertyName[?Yield, ?Await]
  </emu-grammar>
  <emu-alg>
    1. Return PropName of |PropertyName|.
  </emu-alg>

  <emu-grammar>
      ClassElementName[Yield, Await] : PrivateName
  </emu-grammar>
  <emu-alg>
    1. Return ~empty~.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-runtime-semantics-evaluate-name">
  <h1>Runtime Semantics: Evaluation</h1>
  <emu-grammar>
      ClassElementName[Yield, Await] : PropertyName[?Yield, ?Await]
  </emu-grammar>
  <emu-alg>
    1. Return the result of evaluating |PropertyName|.
  </emu-alg>

  <emu-grammar>
      ClassElementName[Yield, Await] : PrivateName
  </emu-grammar>
  <emu-alg>
    1. Let _bindingName_ be StringValue of |PrivateName|.
    1. Let _field_ be NewPrivateName(_bindingName_).
    1. Let _scope_ be the running execution context's PrivateNameEnvironment.
    1. Let _scopeEnvRec_ be _scope_'s EnvironmentRecord.
    1. Perform ! _scopeEnvRec_.InitializeBinding(_bindingName_, _field_).
    1. Return _field_.
  </emu-alg>
  <emu-note type=editor>Each time a class declaration executes, distinct internal Private Names are created. This means, that they cannot directly access each other's private state if a method of one is called with the other as a receiver.</emu-note>

</emu-clause>

<emu-clause id="static-semantics-class-element-evaluation">
  <h1>Static Semantics: ClassElementEvaluation</h1>
  <p>With parameters _object_ and _enumerable_.</p>

  <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
  <emu-alg>
    1. Return ClassFieldDefinitionEvaluation of |FieldDefinition| with parameter *true* and _object_.
  </emu-alg>

  <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
  <emu-alg>
    1. Return ClassFieldDefinitionEvaluation of |FieldDefinition| with parameter *false* and _object_.
  </emu-alg>
  <emu-grammar>
      ClassElement : MethodDefinition
      ClassElement : `static` MethodDefinition
  </emu-grammar>
  <emu-alg>
    1. Perform ? PropertyDefinitionEvaluation with parameters _object_ and _enumerable_.
    1. Return an empty List.
  </emu-alg>
</emu-clause>

<emu-clause id="runtime-semantics-class-field-definition-evaluation">
  <h1>Runtime Semantics: ClassFieldDefinitionEvaluation</h1>

  <p>With parameters _isStatic_ and _homeObject_.</p>

  <emu-grammar>
    FieldDefinition : ClassElementName Initializer?
  </emu-grammar>
  <emu-alg>
    1. Let _fieldName_ be the result of evaluating |ClassElementName|.
    1. ReturnIfAbrupt(_fieldName_).
    1. If |Initializer_opt| is present,
      1. Let _lex_ be the Lexical Environment of the running execution context.
      1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.
      1. Let _initializer_ be FunctionCreate(~Method~, _formalParameterList_, |Initializer|, _lex_, *true*).
      1. Perform MakeMethod(_initializer_, _homeObject_).
      1. Let _isAnonymousFunctionDefinition_ be IsAnonymousFunctionDefinition(|Initializer|).
    1. Else,
      1. Let _initializer_ be ~empty~.
      1. Let _isAnonymousFunctionDeclaration_ be *false*.
    1. Return a List containing Record {
         [[Name]]: _fieldName_, 
         [[Initializer]]: _initializer_,
         [[Static]]: _isStatic_,
         [[IsAnonymousFunctionDefinition]]: _isAnonymousFunctionDefinition_
       }.
  </emu-alg>
</emu-clause>

<emu-clause id="runtime-semantics-class-public-field-definition-evaluation">
  <h1>Runtime Semantics: EvaluateBody</h1>

  <p>With parameter _functionObject_ and List _argumentsList_.</p>

  <emu-grammar>
    Initializer :
      `=` AssignmentExpression
  </emu-grammar>
  <emu-alg>
    1. Assert: _argumentsList_ is empty.
    1. Return the result of evaluating |AssignmentExpression|.
  </emu-alg>
  <emu-note>FunctionDeclarationInstantiate would not have any observable behaviour here, so its call is omitted.</emu-note>
</emu-clause>

    <!-- es6num="9.2.11" -->
    <emu-clause id="sec-setfunctionname" aoid="SetFunctionName">
      <h1>SetFunctionName ( _F_, _name_ [ , _prefix_ ] )</h1>
      <p>The abstract operation SetFunctionName requires a Function argument _F_, a String, Symbol, <ins>or Private Name</ins> argument _name_ and optionally a String argument _prefix_. This operation adds a `name` property to _F_ by performing the following steps:</p>
      <emu-alg>
        1. Assert: _F_ is an extensible object that does not have a `name` own property.
        1. Assert: Type(_name_) is either Symbol, String, <ins>or Private Name</ins>.
        1. Assert: If _prefix_ was passed, then Type(_prefix_) is String.
        1. If Type(_name_) is Symbol, then
          1. Let _description_ be _name_'s [[Description]] value.
          1. If _description_ is *undefined*, set _name_ to the empty String.
          1. Else, set _name_ to the concatenation of `"["`, _description_, and `"]"`.
        1. <ins>Else if _name_ is a Private Name,</ins>
          1. <ins>Set _name_ to _name_'s [[Description]] value.</ins>
        1. If _prefix_ was passed, then
          1. Set _name_ to the concatenation of _prefix_, code unit 0x0020 (SPACE), and _name_.
        1. Return ! DefinePropertyOrThrow(_F_, `"name"`, PropertyDescriptor{[[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true*}).
      </emu-alg>
    </emu-clause>

<emu-clause id="sec-define-field">
  <h1>DefineField(_receiver_, _fieldRecord_)</h1>
    <emu-alg>
    1. Assert: Type(_receiver_) is Object.
    1. Assert: _fieldRecord_ is a Record as created by ClassFieldDefinitionEvaluation.
    1. Let _fieldName_ be _fieldRecord_.[[Name]].
    1. Let _initializer_ be _fieldRecord_.[[Initializer]].
    1. If _initializer_ is not ~empty~, then
      1. Let _initValue_ be ? Call(_initializer_, _receiver_).
    1. Else, let _initValue_ be *undefined*.
    1. If _fieldRecord_.[[IsAnonymousFunctionDefinition]] is *true*, then
      1. Let _hasNameProperty_ be ? HasOwnProperty(_initValue_, `"name"`).
      1. If _hasNameProperty_ is *false*, perform SetFunctionName(_initValue_, _fieldName_).
    1. If _fieldName_ is a Private Name,
      1. Perform ? PrivateFieldAdd(_fieldName_, _receiver_, _initialValue_).
    1. Else,
      1. NOTE: _fieldName_ is a property key.
      1. Let _desc_ be PropertyDescriptor{
           [[Configurable]]: *true*,
           [[Enumerable]]: *true*,
           [[Writable]]: *true*,
           [[Value]]: _initValue_
         }.
      1. Perform ? DefinePropertyOrThrow(_receiver_, _fieldName_, _desc_).
    <emu-alg>
</emu-clause>


<emu-clause id="initialize-public-static-fields">
  <h1>InitializeStaticFields(_F_)</h1>

  <emu-alg>
    1. Assert: Type(_F_) is Object.
    1. Assert: _F_ is an ECMAScript function object.
    1. Let _fieldRecords_ be the value of _F_'s [[Fields]] internal slot.
    1. For each item _fieldRecord_ in order from _fieldRecords_,
      1. If _fieldRecord_.[[static]] is *true*, then
        1. Perform ? DefineField(_F_, _fieldRecord_).
    1. Return.
  </emu-alg>
</emu-clause>

<emu-clause id="initialize-public-instance-fields">
  <h1>InitializeInstanceFields ( _O_, _constructor_ )</h1>

  <emu-alg>
    1. Assert: Type ( _O_ ) is Object.
    1. Assert: Assert _constructor_ is an ECMAScript function object.
    1. Let _fieldRecords_ be the value of _constructor_'s [[Fields]] internal slot.
    1. For each item _fieldRecord_ in order from _fieldRecords_,
      1. If _fieldRecord_.[[static]] is *false*, then
        1. Perform ? DefineField(_O_, _fieldRecord_).
    1. Return.
  </emu-alg>
  <emu-note type=editor>Private fields are added to the object one by one, interspersed with evaluation of the initializers, following the construction of the receiver. These semantics allow for a later initializer to refer to a previously private field.</emu-note>
</emu-clause>

<emu-clause id="sec-private-names-static-semantics-stringvalue">
  <h1>Static Semantics: StringValue</h1>
  <emu-see-also-para op="StringValue"></emu-see-also-para>
  <emu-grammar>
    PrivateName ::
      `#` IdentifierName
  </emu-grammar>
  <emu-alg>
    1. Return the String value consisting of the sequence of code units corresponding to |PrivateName|. In determining the sequence any occurrences of `\\` |UnicodeEscapeSequence| are first replaced with the code point represented by the |UnicodeEscapeSequence| and then the code points of the entire |PrivateName| are converted to code units by UTF16Encoding (<emu-xref href="#sec-utf16encoding"></emu-xref>) each code point.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-private-bound-names" aoid="PrivateBoundNames">
  <h1>Static Semantics: PrivateBoundNames</h1>
  <emu-grammar>
      FieldDefinition : ClassElementName Initializer?
  </emu-grammar>
  <emu-alg>
    1. Return PrivateBoundNames of |ClassElementName|
  </emu-alg>

  <emu-grammar>
    ClassElementName : PrivateName
  </emu-grammar>
  <emu-alg>
    1. Return a new List containing the StringValue of |PrivateName|.
  </emu-alg>

  <emu-grammar>
    ClassElementName : PropertyName
  </emu-grammar>
  <emu-alg>
    1. Return a new empty List.
  </emu-alg>

  <emu-grammar>
    ClassElement : MethodDefinition `;`

    ClassElement : `static` MethodDefinition `;`

    ClassElement : `;`
  </emu-grammar>
  <emu-alg>
    1. Return a new empty List.
  </emu-alg>

  <emu-grammar>
    ClassElementList : ClassElement
  </emu-grammar>
  <emu-alg>
    1. Return PrivateBoundNames of |ClassElement|.
  </emu-alg>

  <emu-grammar>
    ClassElementList : ClassElementList ClassElement
  </emu-grammar>
  <emu-alg>
    1. Let _names_ be PrivateBoundNames of |ClassElementList|.
    1. Append to _names_ the elements of PrivateBoundNames of |ClassElement|.
    1. Return _names_.
  </emu-alg>

  <emu-grammar>
    ClassBody : ClassElementList
  </emu-grammar>
  <emu-alg>
    1. Return PrivateBoundNames of |ClassElementList|.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-static-semantics-contains-arguments">
  <h1>Static Semantics: ContainsArguments</h1>
  <emu-grammar>
    IdentifierReference : Identifier
  </emu-grammar>
  <emu-alg>
    1. If the StringValue of |Identifier| is `"arguments"`, return *true*.
    2. Else, return *false*.
  </emu-alg>

  <emu-grammar>
    FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`

    FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`

    FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return *false*.
  </emu-alg>

  <emu-grammar>
    MethodDefinition :
      PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
      `get` PropertyName `(` `)` `{` FunctionBody `}`
      `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return the result of ContainsArguments for |PropertyName|.
  </emu-alg>

  <emu-grammar>
    GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return the result of ContainsArguments for |PropertyName|.
  </emu-alg>

  <emu-grammar>
    GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

    GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

    GeneratorExpression : `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return *false*.
  </emu-alg>

  <emu-grammar>ClassBody : ClassElementList</emu-grammar>
  <emu-alg>
    1. Return *false*.
  </emu-alg>

  <emu-grammar>
    AsyncMethod : `async` [no LineTerminator here] PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return the result of ContainsArguments for |PropertyName|.
  </emu-alg>

  <emu-grammar>
    AsyncFunctionDeclaration : `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`

    AsyncFunctionDeclaration : `async` [no LineTerminator here] `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

    AsyncFunctionExpression : `async` [no LineTerminator here] `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

    AsyncFunctionExpression : `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return *false*.
  </emu-alg>

  For all other grammatical productions, recurse on all nonterminals. If any piece returns *true*, then return *true*. Otherwise return *false*.
  <emu-note type=editor>TODO: Elaborate the preceding paragraph with spec text inserted in each relevant place</emu-note>
</emu-clause>

    <emu-clause id="sec-static-semantics-nonconstructorelementdefinitions">
      <h1>Static Semantics: NonConstructorElementDefinitions</h1>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. If |ClassElement| is <emu-grammar>ClassElement : `;`</emu-grammar>, return a new empty List.
        1. <ins>If |ClassElement| is <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>, return a new empty List.</ins>
        1. <ins>If |ClassElement| is <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>, return a new empty List.</ins>
        1. If IsStatic of |ClassElement| is *false* and PropName of |ClassElement| is `"constructor"`, return a new empty List.
        1. Return a List containing |ClassElement|.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. Let _list_ be NonConstructorElementDefinitions of |ClassElementList|.
        1. If |ClassElement| is <emu-grammar>ClassElement : `;`</emu-grammar> , return _list_.
        1. <ins>If |ClassElement| is <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>, return a new empty List.</ins>
        1. <ins>If |ClassElement| is <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>, return a new empty List.</ins>
        1. If IsStatic of |ClassElement| is *false* and PropName of |ClassElement| is `"constructor"`, return _list_.
        1. Append |ClassElement| to the end of _list_.
        1. Return _list_.
      </emu-alg>
    </emu-clause>

<emu-clause id="class-definitions">
  <h1>Class Definitions</h1>

  <emu-clause id="static-semantics-is-static">
    <h1>Static Semantics: IsStatic</h1>

    <ins class="block">
      <emu-grammar>ClassElement : FieldDefinition</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>

      <emu-grammar>ClassElement : static FieldDefinition</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </ins>
  </emu-clause>

  <emu-clause id="runtime-semantics-class-definition-evaluation">
    <h1>Runtime Semantics: ClassDefinitionEvaluation</h1>
    <p>With parameter _className_.</p>
    <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
    <emu-alg>
      1. Let _lex_ be the LexicalEnvironment of the running execution context.
      1. Let _classScope_ be NewDeclarativeEnvironment(_lex_).
      1. Let _classScopeEnvRec_ be _classScope_'s EnvironmentRecord.
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.CreateImmutableBinding(_className_, *true*).
      1. <ins>Let _outerPrivateEnvironment_ be the PrivateNameEnvironment of the running execution context.</ins>
      1. <ins>Let _classPrivateEnvironment_ be NewDeclarativeEnvironment(_outerPrivateEnvironment_).</ins>
      1. <ins>Let _classPrivateEnvRec_ be _classPrivateEnvironment_'s EnvironmentRecord.</ins>
      1. <ins>If |ClassBody_opt| is present, then</ins>
        1. <ins>For each element _dn_ of the PrivateBoundNames of |ClassBody_opt|,</ins>
          1. <ins>Perform _classPrivateEnvRec_.CreateImmutableBinding(_dn_, *true*).</ins>
      1. If |ClassHeritage_opt| is not present, then
        1. Let _protoParent_ be the intrinsic object %ObjectPrototype%.
        1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
      1. Else,
        1. Set the running execution context's LexicalEnvironment to _classScope_.
        1. Let _superclass_ be the result of evaluating |ClassHeritage|.
        1. Set the running execution context's LexicalEnvironment to _lex_.
        1. ReturnIfAbrupt(_superclass_).
        1. If _superclass_ is *null*, then
          1. Let _protoParent_ be *null*.
          1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
        1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
        1. Else,
          1. Let _protoParent_ be ? Get(_superclass_, `"prototype"`).
          1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
          1. Let _constructorParent_ be _superclass_.
      1. Let _proto_ be ObjectCreate(_protoParent_).
      1. If |ClassBody_opt| is not present, let _constructor_ be ~empty~.
      1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
      1. If _constructor_ is ~empty~, then
        1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor(... args){ super (...args);}</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
        1. Else,
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor( ){ }</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
      1. Set the running execution context's LexicalEnvironment to _classScope_.
      1. <ins>Set the running execution context's PrivateNameEnvironment to _classPrivateEnvironment_.</ins>
      1. Let _constructorInfo_ be the result of performing DefineMethod for _constructor_ with arguments _proto_ and _constructorParent_ as the optional _functionPrototype_ argument.
      1. Assert: _constructorInfo_ is not an abrupt completion.
      1. Let _F_ be _constructorInfo_.[[Closure]].
      1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then set _F_.[[ConstructorKind]] to `"derived"`.
      1. Perform MakeConstructor(_F_, *false*, _proto_).
      1. Perform MakeClassConstructor(_F_).
      1. Perform CreateMethodProperty(_proto_, `"constructor"`, _F_).
      1. If |ClassBody_opt| is not present, let _methods_ be a new empty List.
      1. Else, let <del>_methods_</del><ins>_elements_</ins> be NonConstructor<del>Method</del><ins>Element</ins>Definitions of |ClassBody|.
      1. Let _fieldRecords_ be a new empty List.
      1. For each |ClassElement| <del>_m_</del><ins>_e_</ins> in order from <del>_methods_</del><ins>_elements_</ins>
        1. If IsStatic of <del>_m_</del><ins>_e_</ins> is *false*, then
          1. Let _fields_ be the result of performing <del>PropertyDefinitionEvaluation for _m_</del><ins>ClassElementEvaluation for _e_</ins> with arguments _proto_ and *false*.
        1. Else,
          1. Let _fields_ be the result of performing <del>PropertyDefinitionEvaluation for _m_</del><ins>ClassElementEvaluation for _e_</ins> with arguments _F_ and *false*.
        1. If _fields_ is an abrupt completion, then
          1. Set the running execution context's LexicalEnvironment to _lex_.
          1. <ins>Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.</ins>
          1. Return Completion(_status_).
        1. <ins>Append _fields_ to _fieldRecords_</ins>
      1. Set the running execution context's LexicalEnvironment to _lex_.
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.InitializeBinding(_className_, _F_).
      1. <ins>Set the value of _F_'s [[Fields]] internal slot to _fieldRecords_.</ins>
      1. <ins>Set the running execution context's LexicalEnvironment to _classScope_.</ins>
      1. <ins>Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.</ins>
      1. <ins>Let _result_ be InitializeStaticFields(_F_).</ins>
      1. <ins>If _result_ is an abrupt completion, then</ins>
        1. <ins>Set the running execution context's LexicalEnvironment to _lex_.</ins>
        1. <ins>Return Completion(_result_)</ins>
      1. <ins>Set the running execution context's LexicalEnvironment to _lex_.</ins>
      1. Return _F_.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="[[construct]]">
  <h1>[[Construct]] ( _argumentsList_, _newTarget_)</h1>
  <p>
    The [[Construct]] internal method for an ECMAScript Function object _F_ is
    called with parameters _argumentsList_ and _newTarget_. _argumentsList_ is
    a possibly empty List of ECMAScript language values. The following steps are
    taken:
  </p>
  <emu-alg>
    1. Assert: _F_ is an ECMAScript function object.
    1. Assert: Type(_newTarget_) is Object.
    1. Let _callerContext_ be the running execution context.
    1. Let _kind_ be _F_.[[ConstructorKind]].
    1. If _kind_ is `"base"`, then
      1. Let _thisArgument_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%ObjectPrototype%"`).
    1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, _newTarget_).
    1. Assert: _calleeContext_ is now the running execution context.
    1. If _kind_ is `"base"`, then
      1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).
      1. <ins>Let _result_ be InitializeInstanceFields(_thisArgument_, _F_).</ins>
      1. <ins>If _result_ is an abrupt completion, then</ins>
        1. <ins>Remove _calleeContext_ from execution context stack and restore
           _callerContext_ as the running execution context.</ins>
        1. <ins>Return Completion(_result_).</ins>
    1. Let _constructorEnv_ be the LexicalEnvironment of _calleeContext_.
    1. Let _envRec_ be _constructorEnv_'s EnvironmentRecord.
    1. Let _result_ be OrdinaryCallEvaluateBody(_F_, _argumentsList_).
    1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
    1. If _result_.[[Type]] is ~return~, then
      1. If Type(_result_.[[Value]]) is Object, return NormalCompletion(_result_.[[Value]]).
      1. If _kind_ is `"base"`, return NormalCompletion(_thisArgument_).
      1. If _result_.[[Value]] is not *undefined*, throw a *TypeError* exception.
    1. Else, ReturnIfAbrupt(_result_).
    1. Return ? _envRec_.GetThisBinding().
  </emu-alg>
  <emu-note type=editor>Fields are added by the base class constructor when the super chain reaches up to that, rather than by the subclass constructor when creating the object, in order to be analogous to ES2015 subclassable builtins. See <a href="https://github.com/tc39/proposal-private-fields/issues/17">this GitHub thread</a> for more discussion.</emu-note>
</emu-clause>

<emu-clause id="the-super-keyword">
  <h1>The `super` Keyword</h1>

  <emu-clause id="sec-super-keyword-runtime-semantics-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>
    <emu-grammar>SuperCall : `super` Arguments</emu-grammar>
    <emu-alg>
      1. Let _newTarget_ be GetNewTarget().
      1. If _newTarget_ is *undefined*, throw a *ReferenceError* exception.
      1. Let _func_ be ? GetSuperConstructor().
      1. Let _argList_ be ArgumentListEvaluation of |Arguments|.
      1. ReturnIfAbrupt(_argList_).
      1. Let _result_ be ? Construct(_func_, _argList_, _newTarget_).
      1. Let _thisER_ be GetThisEnvironment( ).
      1. <ins>Perform ? InitializeInstanceFields(_thisValue_, _F_).</ins>
      1. Return ? _thisER_.BindThisValue(_result_).
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-delete-operator">
  <h1>The `delete` Operator</h1>

  <emu-clause id="sec-delete-operator-runtime-semantics-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>
    <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
    <emu-alg>
      1. Let _ref_ be the result of evaluating |UnaryExpression|.
      1. ReturnIfAbrupt(_ref_).
      1. If Type(_ref_) is not Reference, return *true*.
      1. If IsUnresolvableReference(_ref_) is *true*, then
        1. Assert: IsStrictReference(_ref_) is *false*.
        1. Return *true*.
      1. If IsPropertyReference(_ref_) is *true*, then
        1. <ins>Assert: IsPrivateReference(_ref_) is *false*.</ins>
        1. If IsSuperReference(_ref_), throw a *ReferenceError* exception.
        1. Let _baseObj_ be ! ToObject(GetBase(_ref_)).
        1. Let _deleteStatus_ be ? _baseObj_.[[Delete]](GetReferencedName(_ref_)).
        1. If _deleteStatus_ is *false* and IsStrictReference(_ref_) is *true*, throw a *TypeError* exception.
        1. Return _deleteStatus_.
      1. Else _ref_ is a Reference to an Environment Record binding,
        1. Let _bindings_ be GetBase(_ref_).
        1. Return ? _bindings_.DeleteBinding(GetReferencedName(_ref_)).
    </emu-alg>
    <emu-note>
      <p>When a `delete` operator occurs within strict mode code, a *SyntaxError* exception is thrown if its |UnaryExpression| is a direct reference to a variable, function argument, or function name. In addition, if a `delete` operator occurs within strict mode code and the property to be deleted has the attribute { [[Configurable]]: *false* }, a *TypeError* exception is thrown.</p>
    </emu-note>
  </emu-clause>
</emu-clause>


</emu-clause>

<emu-clause id="sec-private-names">
  <h1>Private Names and references</h1>
<p>The <dfn>Private Name</dfn> specification type is used to describe a globally unique identifier which represents a private field name. A private name may be installed on any ECMAScript object with the PrivateFieldAdd internal algorithm, and then read or written using PrivateFieldGet and PrivateFieldSet.</p>

  <p>Each PrivateName value immutably holds an associated value called [[Description]] that is a String value.</p>

<p>All ECMAScript objects have a new additional internal slot, [[PrivateFieldValues]], which is a List of Records of the form { [[PrivateName]]: Private Name, [[PrivateFieldValue]]: ECMAScript value }. This List represents the values of the private fields for the object. All objects, including Proxies and all host environment-provided objects, have this internal slot, but primitives such as Numbers do not.</p>

<emu-note type=editor>
<p>
  Private fields are designed to have semantics analogous to WeakMaps. However, the implied garbage collection semantics are weaker: If all the references to a WeakMap are inaccessible, but there is still a reference to a key which was in the WeakMap, one would expect the value to be eventually collected. However, PrivateNameIdentifiers specifically do not have this connotation: because the reference from the Identifier to the Value is in a Record which the Object points to, the value would not be collected, even if nothing else points to the identifier.
</p>
<p>
  Private Names are a specification type here, not directly observable to ECMAScript code. However, in <a href="https://github.com/tc39/proposal-private-fields/blob/master/DECORATORS.md">a decorator integration strawman</a>, an object wrapping Private Names would be exposed to allow greater metaprogramming.
</p>
</emu-note>

<emu-note type=editor>
  Private fields are deliberately inaccessible outside of the class body. It is proposed that there could be an "escape hatch" to access them though some sort of reflective mechanism; see <a href="https://github.com/tc39/proposal-private-fields/issues/33">the GitHub thread</a>. This proposal deliberately omits any such escape hatch.
</emu-note>

<emu-clause id="sec-objectcreate" aoid="ObjectCreate">
  <h1>ObjectCreate (_proto_ [ , _internalSlotsList_ ])</h1>
  <p>The abstract operation ObjectCreate with argument _proto_ (an object or null) is used to specify the runtime creation of new ordinary objects. The optional argument _internalSlotsList_ is a List of the names of additional internal slots that must be defined as part of the object. If the list is not provided, a new empty List is used. This abstract operation performs the following steps:</p>
  <emu-alg>
    1. If _internalSlotsList_ was not provided, let _internalSlotsList_ be a new empty List.
    1. Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.
    1. Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.
    1. Set _obj_.[[Prototype]] to _proto_.
    1. Set _obj_.[[Extensible]] to *true*.
    1. <ins>Set _obj_.[[PrivateFieldValues]] to an empty List.</ins>
    1. Return _obj_.
  </emu-alg>
  <emu-note type=editor>TODO: All ECMAScript objects, including Proxies, and any user exotic object, should have a [[PrivateFieldValues]] internal slot iniitlaized to an empty List.</emu-note>
</emu-clause>

<emu-clause id="sec-newprivatename" aoid="NewPrivateName">
  <h1>NewPrivateName ( _description_ )</h1>
  <emu-alg>
    1. Return a new unique Private Name value whose [[Description]] value is _description_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-privatefieldfind" aoid="PrivateFieldFind">
  <h1>PrivateFieldFind (_P_, _O_)</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. Assert: _O_ is an object with a [[PrivateFieldValues]] internal slot.
    1. For each element _entry_ in _O_.[[PrivateFieldValues]],
      1. If _entry_.[[PrivateName]] is _P_, return _entry_.
    1. Return ~empty~.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-privatefieldadd" aoid="PrivateFieldAdd">
  <h1>PrivateFieldAdd (_P_, _O_, _value_)</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. If _O_ is not an object, throw a *TypeError* exception.
    1. Let _entry_ be PrivateFieldFind(_P_, _O_).
    1. If _entry_ is not ~empty~, throw a *TypeError* exception.
    1. Append { [[PrivateName]]: P, [[PrivateFieldValue]]: _value_ } to _O_.[[PrivateFieldValues]].
  </emu-alg>
</emu-clause>

<emu-clause id="sec-privatefieldget" aoid="PrivateFieldGet">
  <h1>PrivateFieldGet (_P_, _O_ )</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. If _O_ is not an object, throw a *TypeError* exception.
    1. Let _entry_ be PrivateFieldFind(_P_, _O_).
    1. If _entry_ is ~empty~, throw a *TypeError* exception.
    1. Return _entry_.[[PrivateFieldValue]].
  </emu-alg>
</emu-clause>

<emu-clause id="sec-privatefieldset" aoid="PrivateFieldSet">
  <h1>PrivateFieldSet (_P_, _O_, _value_ )</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. If _O_ is not an object, throw a *TypeError* exception.
    1. Let _entry_ be PrivateFieldFind(_P_, _O_).
    1. If _entry_ is ~empty~, throw a *TypeError* exception.
    1. Set _entry_.[[PrivateFieldValue]] to _value_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-private-references-runtime-semantics-evaluation">
  <h1>Runtime Semantics: Evaluation</h1>
  <emu-grammar>MemberExpression : MemberExpression `.` PrivateName</emu-grammar>
  <emu-alg>
    1. Let _baseReference_ be the result of evaluating |MemberExpression|.
    1. Let _baseValue_ be ? GetValue(_baseReference_).
    1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
    1. Let _fieldNameString_ be the StringValue of |PrivateName|.
    1. Return MakePrivateReference(_bv_, _fieldNameString_).
  </emu-alg>

  <emu-grammar>CallExpression : CallExpression `.` PrivateName</emu-grammar>
  <emu-alg>
    1. Let _baseReference_ be the result of evaluating |CallExpression|.
    1. Let _baseValue_ be ? GetValue(_baseReference_).
    1. Let _bv_ be ? RequireObjectCoercible(_baseValue_).
    1. Let _fieldNameString_ be the StringValue of |PrivateName|.
    1. Return MakePrivateReference(_bv_, _fieldNameString_).
  </emu-alg>
</emu-clause>

<emu-clause id="sec-reference-specification-type">
  <h1>The Reference Specification Type</h1>
  <emu-note>
    <p>The Reference type is used to explain the behaviour of such operators as `delete`, `typeof`, the assignment operators, the `super` keyword and other language features. For example, the left-hand operand of an assignment is expected to produce a reference.</p>
  </emu-note>
  <p>A <dfn>Reference</dfn> is a resolved name or property binding. A Reference consists of <ins>four</ins> components, the <em>base</em> value, the <em>referenced name</em>, the Boolean valued <em>strict reference</em> flag, <ins>and the Boolean valued <em>private reference</em> flag</ins>. The <em>base</em> value is either *undefined*, an Object, a Boolean, a String, a Symbol, a Number, or an Environment Record (<emu-xref href="#sec-environment-records"></emu-xref>). A _base_ value of *undefined* indicates that the Reference could not be resolved to a binding. The <em>referenced name</em> is a String value or a Symbol value.</p>
  <p>A Super Reference is a Reference that is used to represent a name binding that was expressed using the super keyword. A Super Reference has an additional _thisValue_ component and its _base_ value will never be an Environment Record.</p>
  <p>The following abstract operations are used in this specification to access the components of references:</p>
  <ul>
    <li>
      GetBase(V). Returns the _base_ value component of the reference V.
    </li>
    <li>
      GetReferencedName(V). Returns the <i>referenced name</i> component of the reference V.
    </li>
    <li>
      IsStrictReference(V). Returns the <i>strict reference</i> flag component of the reference V.
    </li>
    <li>
      HasPrimitiveBase(V). Returns *true* if Type(_base_) is Boolean, String, Symbol, or Number.
    </li>
    <li>
      IsPropertyReference(V). Returns *true* if either the _base_ value is an object or HasPrimitiveBase(V) is *true*; otherwise returns *false*.
    </li>
    <li>
      IsUnresolvableReference(V). Returns *true* if the _base_ value is *undefined* and *false* otherwise.
    </li>
    <li>
      IsSuperReference(V). Returns *true* if this reference has a _thisValue_ component.
    </li>
    <li>
      <ins>IsPrivateReference(V). Returns the <i>private reference</i> flag component of the reference V.</ins>
    </li>
  </ul>
  <p>The following abstract operations are used in this specification to operate on references:</p>

  <!-- es6num="6.2.3.1" -->
  <emu-clause id="sec-getvalue" aoid="GetValue">
    <h1>GetValue ( _V_ )</h1>
    <emu-alg>
      1. ReturnIfAbrupt(_V_).
      1. If Type(_V_) is not Reference, return _V_.
      1. Let _base_ be GetBase(_V_).
      1. If IsUnresolvableReference(_V_), throw a *ReferenceError* exception.
      1. If IsPropertyReference(_V_), then
        1. If HasPrimitiveBase(_V_), then
          1. Assert: In this case, _base_ will never be *null* or *undefined*.
          1. Let _base_ be ToObject(_base_).
        1. <ins>If IsPrivateReference(_V_), then</ins>
          1. <ins>Let _env_ be the running execution context's PrivateNameEnvironment.</ins>
          1. <ins>Let _field_ be ? ResolveBinding(GetReferencedName(_V_), _env_).</ins>
          1. <ins>Assert: _field_ is a Private Name.</ins>
          1. <ins>Return ? PrivateFieldGet(_field_, _base_).</ins>
        1. Return ? _base_.[[Get]](GetReferencedName(_V_), GetThisValue(_V_)).
      1. Else _base_ must be an Environment Record,
        1. Return ? _base_.GetBindingValue(GetReferencedName(_V_), IsStrictReference(_V_)) (see <emu-xref href="#sec-environment-records"></emu-xref>).
    </emu-alg>
    <emu-note>
      <p>The object that may be created in step 5.a.ii is not accessible outside of the above abstract operation and the ordinary object [[Get]] internal method. An implementation might choose to avoid the actual creation of the object.</p>
    </emu-note>
  </emu-clause>

  <!-- es6num="6.2.3.2" -->
  <emu-clause id="sec-putvalue" aoid="PutValue">
    <h1>PutValue ( _V_, _W_ )</h1>
    <emu-alg>
      1. ReturnIfAbrupt(_V_).
      1. ReturnIfAbrupt(_W_).
      1. If Type(_V_) is not Reference, throw a *ReferenceError* exception.
      1. Let _base_ be GetBase(_V_).
      1. If IsUnresolvableReference(_V_), then
        1. If IsStrictReference(_V_) is *true*, then
          1. Throw a *ReferenceError* exception.
        1. Let _globalObj_ be GetGlobalObject().
        1. Return ? Set(_globalObj_, GetReferencedName(_V_), _W_, *false*).
      1. Else if IsPropertyReference(_V_), then
        1. If HasPrimitiveBase(_V_) is *true*, then
          1. Assert: In this case, _base_ will never be *null* or *undefined*.
          1. Set _base_ to ToObject(_base_).
        1. <ins>If IsPrivateReference(_V_), then</ins>
          1. <ins>Let _env_ be the running execution context's PrivateNameEnvironment.</ins>
          1. <ins>Let _field_ be ? ResolveBinding(GetReferencedName(_V_), _env_).</ins>
          1. <ins>Assert: _field_ is a Private Name.</ins>
          1. <ins>Perform ? PrivateFieldSet(_field_, _base_, _W_).</ins>
        1. Else,
          1. Let _succeeded_ be ? _base_.[[Set]](GetReferencedName(_V_), _W_, GetThisValue(_V_)).
          1. If _succeeded_ is *false* and IsStrictReference(_V_) is *true*, throw a *TypeError* exception.
        1. Return.
      1. Else _base_ must be an Environment Record.
        1. Return ? _base_.SetMutableBinding(GetReferencedName(_V_), _W_, IsStrictReference(_V_)) (see <emu-xref href="#sec-environment-records"></emu-xref>).
    </emu-alg>
    <emu-note>
      <p>The object that may be created in step 6.a.ii is not accessible outside of the above algorithm and the ordinary object [[Set]] internal method. An implementation might choose to avoid the actual creation of that object.</p>
    </emu-note>
  </emu-clause>

  <!--
  1. Replace all occurances of "Return a value of type Reference..." with calls to MakeReference
  2. Rename MakeSuperPropertyReference to MakeSuperReference for consistency.

  <emu-clause id="sec-makereference" aoid="MakeReference">
    <h1>MakeReference ( _baseValue_, _referencedName_, _strict_ )</h1>
    <emu-alg>
      1. Return a value of type Reference whose base value is _baseValue_, whose referenced name is _referencedName_, whose strict reference flag is _strict_, and whose private reference component is *false*.
    </emu-alg>
  </emu-clause>
  -->

  <emu-clause id="sec-makeprivatereference" aoid="MakePrivateReference">
    <h1>MakePrivateReference ( _baseValue_, _fieldName_ )</h1>
    <emu-alg>
      1. Return a value of type Reference whose base value is _baseValue_, whose referenced name is _fieldName_, whose strict reference flag is *true*, and whose private reference component is *true*.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-execution-contexts">
  <h1>Execution Contexts</h1>
    <emu-table id="table-23" caption="Additional State Components for ECMAScript Code Execution Contexts">
      <table>
        <tbody>
        <tr>
          <th>
            Component
          </th>
          <th>
            Purpose
          </th>
        </tr>
        <tr>
          <td>
            LexicalEnvironment
          </td>
          <td>
            Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.
          </td>
        </tr>
        <tr>
          <td>
            VariableEnvironment
          </td>
          <td>
            Identifies the Lexical Environment whose EnvironmentRecord holds bindings created by |VariableStatement|s within this execution context.
          </td>
        </tr>
        <tr>
          <td>
            <ins>PrivateNameEnvironment</ins>
          </td>
          <td>
            <ins>Identifies the Lexical Environment whose EnvironmentRecord holds internal private names created by |FieldDefinition|s.</ins>
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
  <emu-note>The PrivateNameEnvironment Lexical Context is always a chain of Declaration Contexts. Each name begins with `"#"`.</emu-note>

  <emu-note type=editor>Private names could be specified by lumping it all into the LexicalEnvironment. However, this would create false conflicts with object environment records that would need to be resolved. Further, it seems logically cleaner to separate out the distinct namespace into a distinct object.</emu-note>

  When a new execution context is created for an ECMAScript code execution context, the PrivateNameIdentifiers value is inherited from the running execution context, or if none exists, a new Declaration Context with a *null* parent.
  <emu-note type=editor>TODO: Elaborate the preceding paragraph with spec text inserted in each relevant place</emu-note>
</emu-clause>

</emu-clause>
</emu-clause>

